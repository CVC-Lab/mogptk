<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mogptk.gpr.model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mogptk.gpr.model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L1-L716" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import sys
import torch
import numpy as np
from IPython.display import display, HTML
from . import Parameter, Mean, Kernel, MultiOutputKernel, Likelihood, GaussianLikelihood, config, plot_gram
from functools import reduce
import operator

def prod(iterable):
    return reduce(operator.mul, iterable, 1)

def init_inducing_points(Z, X, kernel):
    # TODO: instead of linspace, use quantile space or k-means to initialize positions
    output_dims = kernel.output_dims
    if 1 &lt; output_dims:
        if isinstance(Z, int) or all(isinstance(z, int) for z in Z) and len(Z) == output_dims:
            if isinstance(Z, int):
                Z = [Z] * output_dims
            M = Z
            Z = torch.zeros((sum(M),X.shape[1]))
            for j in range(len(M)):
                m0 = sum(M[:j])
                m = M[j]
                Z[m0:m0+m,0] = j
                for i in range(X.shape[1])[1:]:
                    x = X[X[:,0] == j,:]
                    Z[m0:m0+m,i] = torch.linspace(torch.min(x[:,i]), torch.max(x[:,i]), m)
    elif isinstance(Z, int):
        M = Z
        Z = torch.zeros((M,X.shape[1]))
        # TODO: this puts values &#34;diagonal&#34;, better to use grid?
        for i in range(X.shape[1]):
            Z[:,i] = torch.linspace(torch.min(X[:,i]), torch.max(X[:,i]), M)
    return Z

class CholeskyException(Exception):
    def __init__(self, message, K, model):
        self.message = message
        self.K = K
        self.model = model

    def __str__(self):
        return self.message

class Model:
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0), jitter=1e-8, mean=None, name=None):
        if not issubclass(type(kernel), Kernel):
            raise ValueError(&#34;kernel must derive from mogptk.gpr.Kernel&#34;)
        X, y = self._check_input(X, y)
        if mean is not None:
            if not issubclass(type(mean), Mean):
                raise ValueError(&#34;mean must derive from mogptk.gpr.Mean&#34;)
            mu = mean(X).reshape(-1,1)
            if mu.shape != y.shape:
                raise ValueError(&#34;mean and y data must match shapes: %s != %s&#34; % (mu.shape, y.shape))

        if likelihood.output_dims != 1 and likelihood.output_dims != kernel.output_dims:
            raise ValueError(&#34;kernel and likelihood must have matching output dimensions&#34;)
        likelihood.validate_y(y)

        # limit to number of significant digits
        if config.dtype == torch.float32:
            jitter = max(jitter, 1e-6)
        elif config.dtype == torch.float64:
            jitter = max(jitter, 1e-15)

        self.kernel = kernel
        self.X = X
        self.y = y
        self.likelihood = likelihood
        self.jitter = jitter
        self.mean = mean
        self.name = name
        self.input_dims = X.shape[1]

        self._params = []
        self._register_parameters(kernel)
        self._register_parameters(likelihood)
        if mean is not None and issubclass(type(mean), Mean):
            self._register_parameters(mean)

    def __setattr__(self, name, val):
        if hasattr(self, name) and isinstance(getattr(self, name), Parameter):
            raise AttributeError(&#34;parameter is read-only, use Parameter.assign()&#34;)
        super().__setattr__(name, val)        

    def _check_input(self, X, y=None):
        if not isinstance(X, torch.Tensor):
            X = torch.tensor(X, device=config.device, dtype=config.dtype)
        else:
            X = X.to(config.device, config.dtype)
        if X.ndim == 0:
            X = X.reshape(1,1)
        elif X.ndim == 1:
            X = X.reshape(-1,1)
        elif X.ndim != 2:
            raise ValueError(&#34;X must have dimensions (data_points,input_dims) with input_dims optional&#34;)
        if X.shape[0] == 0 or X.shape[1] == 0:
            raise ValueError(&#34;X must not be empty&#34;)

        if y is not None:
            if not isinstance(y, torch.Tensor):
                y = torch.tensor(y, device=config.device, dtype=config.dtype)
            else:
                y = y.to(config.device, config.dtype)
            if y.ndim == 0:
                y = y.reshape(1,1)
            elif y.ndim == 1:
                y = y.reshape(-1,1)
            elif y.ndim != 2 or y.shape[1] != 1:
                raise ValueError(&#34;y must have one dimension (data_points,)&#34;)
            if X.shape[0] != y.shape[0]:
                raise ValueError(&#34;number of data points for X and y must match&#34;)
            return X, y
        else:
            # X is for prediction
            if X.shape[1] != self.input_dims:
                raise ValueError(&#34;X must have %s input dimensions&#34; % self.input_dims)
            return X

    def _index_channel(self, value, X):
        if 1 &lt; self.kernel.output_dims and 0 &lt; value.ndim and value.shape[0] == self.kernel.output_dims:
            return torch.index_select(value, dim=0, index=X[:,0].long())
        return value

    def _register_parameters(self, obj, name=None):
        if isinstance(obj, Parameter):
            if obj.name is not None:
                if name is None:
                    name = obj.name
                else:
                    name += &#34;.&#34; + obj.name
            elif name is None:
                name = &#34;&#34;
            obj.name = name
            self._params.append(obj)
        elif isinstance(obj, list):
            for i, v in enumerate(obj):
                self._register_parameters(v, (name if name is not None else &#34;&#34;)+&#34;[&#34;+str(i)+&#34;]&#34;)
        elif issubclass(type(obj), (Kernel, Mean, Likelihood)):
            for v in obj.__dict__.values():
                self._register_parameters(v, (name+&#34;.&#34; if name is not None else &#34;&#34;)+obj.name)

    def zero_grad(self):
        for p in self._params:
            p = p.unconstrained
            if p.grad is not None:
                if p.grad.grad_fn is not None:
                    p.grad.detach_()
                else:
                    p.grad.requires_grad_(False)
                p.grad.zero_()

    def parameters(self):
        for p in self._params:
            if p.trainable:
                yield p.unconstrained

    def get_parameters(self):
        return self._params
    
    def print_parameters(self, file=None):
        def param_range(lower, upper, trainable=True, pegged=False):
            if lower is not None:
                if prod(lower.shape) == 1:
                    lower = lower.item()
                else:
                    lower = lower.tolist()
            if upper is not None:
                if prod(upper.shape) == 1:
                    upper = upper.item()
                else:
                    upper = upper.tolist()

            if pegged:
                return &#34;pegged&#34;
            elif not trainable:
                return &#34;fixed&#34;
            if lower is None and upper is None:
                return &#34;(-∞, ∞)&#34;
            elif lower is None:
                return &#34;(-∞, %s]&#34; % upper
            elif upper is None:
                return &#34;[%s, ∞)&#34; % lower
            return &#34;[%s, %s]&#34; % (lower, upper)

        if file is None:
            try:
                get_ipython  # fails if we&#39;re not in a notebook
                table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;&lt;th&gt;Range&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
                for p in self._params:
                    table += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (p.name, param_range(p.lower, p.upper, p.trainable, p.pegged), p.numpy())
                table += &#39;&lt;/table&gt;&#39;
                display(HTML(table))
                return
            except Exception as e:
                pass

        vals = [[&#34;Name&#34;, &#34;Range&#34;, &#34;Value&#34;]]
        for p in self._params:
            vals.append([p.name, param_range(p.lower, p.upper, p.trainable, p.pegged), str(p.numpy())])

        nameWidth = max([len(val[0]) for val in vals])
        rangeWidth = max([len(val[1]) for val in vals])
        for val in vals:
            print(&#34;%-*s  %-*s  %s&#34; % (nameWidth, val[0], rangeWidth, val[1], val[2]), file=file)

    def _cholesky(self, K, add_jitter=False):
        if add_jitter:
            K += (self.jitter * K.diagonal().mean()).repeat(K.shape[0]).diagflat()
        try:
            return torch.linalg.cholesky(K)
        except RuntimeError as e:
            print(&#34;ERROR:&#34;, e.args[0], file=sys.__stdout__)
            if K.isnan().any():
                print(&#34;ERROR: kernel matrix has NaNs!&#34;, file=sys.__stdout__)
            if K.isinf().any():
                print(&#34;ERROR: kernel matrix has infinities!&#34;, file=sys.__stdout__)
            self.print_parameters()
            plot_gram(K)
            raise CholeskyException(e.args[0], K, self)

    def log_marginal_likelihood(self):
        raise NotImplementedError()

    def log_prior(self):
        return sum([p.log_prior() for p in self._params])

    def loss(self):
        self.zero_grad()
        loss = -self.log_marginal_likelihood() - self.log_prior()
        loss.backward()
        return loss

    def K(self, X1, X2=None):
        with torch.no_grad():
            return self.kernel(X1, X2).cpu().numpy() # does cpu().numpy() detach? check memory usage

    def quantile(self, p, mu, var):
        with torch.no_grad():
            if not isinstance(p, torch.Tensor):
                p = torch.tensor(p, device=config.device, dtype=config.dtype)
            else:
                p = p.to(config.device, config.dtype)
            p = p.squeeze()
            if p.ndim != 0:
                raise ValueError(&#34;quantile must be scalar&#34;)
            return self.likelihood.quantile(p, mu, var)

    def sample(self, Z, n=None, predict_y=True):
        with torch.no_grad():
            S = n
            if n is None:
                S = 1

            # TODO: predict_y and non-Gaussian likelihoods
            mu, var = self.predict(Z, full=True, tensor=True, predict_y=predict_y)  # MxD and MxMxD
            eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
            var += self.jitter * var.diagonal().mean() * eye  # MxM

            u = torch.normal(
                    torch.zeros(Z.shape[0], S, device=config.device, dtype=config.dtype),
                    torch.tensor(1.0, device=config.device, dtype=config.dtype))  # MxS
            L = torch.linalg.cholesky(var)  # MxM
            samples = mu + L.mm(u)  # MxS

            if n is None:
                samples = samples.squeeze()
            return samples.cpu().numpy()

class Exact(Model):
    def __init__(self, kernel, X, y, variance=1.0, jitter=1e-8, mean=None, name=&#34;Exact&#34;):
        # turn on Gaussian likelihood variance per channel and or per data point
        # variance shape will be (channels,data_points), where if either is unity, the variance will be equal amonst all channels or data points respectively
        variance = Parameter.to_tensor(variance).squeeze()
        if variance.ndim == 1 and 0 &lt; X.ndim and variance.shape[0] == X.shape[0]:
            variance = variance.reshape(1,-1)
        elif variance.ndim == 0 or variance.ndim == 1 and variance.shape[0] == 1:
            variance = variance.repeat(kernel.output_dims)
        elif variance.ndim != 1 or variance.shape[0] != kernel.output_dims:
            raise ValueError(&#34;variance must have shape (channels,) or (data_points,)&#34;)

        super().__init__(kernel, X, y, GaussianLikelihood(variance), jitter, mean, name)
        self.likelihood.variance.trainable = variance.ndim == 1

        self.eye = torch.eye(self.X.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)

    def log_marginal_likelihood(self):
        Kff = self.kernel.K(self.X)
        if self.likelihood.variance().ndim == 2:
            Kff += self.likelihood.variance()[0,:].diagflat()
        else:
            Kff += self._index_channel(self.likelihood.variance(), self.X) * self.eye  # NxN
        L = self._cholesky(Kff, add_jitter=True)  # NxN

        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken inside the log: L is the square root
        p -= 0.5*y.T.mm(torch.cholesky_solve(y,L)).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        if self.likelihood.variance().ndim == 2 and predict_y:
            raise ValueError(&#34;can only predict f when data point variances are given, set predict_y=False&#34;)

        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff = self.kernel.K(self.X)
            if self.likelihood.variance().ndim == 2:
                Kff += self.likelihood.variance()[0,:].diagflat()
            else:
                Kff += self._index_channel(self.likelihood.variance(), self.X) * self.eye  # NxN
            Kfs = self.kernel.K(self.X,Xs)  # NxM

            Lff = self._cholesky(Kff, add_jitter=True)  # NxN
            v = torch.linalg.solve_triangular(Lff,Kfs,upper=False)  # NxM

            mu = Kfs.T.mm(torch.cholesky_solve(y,Lff))  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel.K(Xs)  # MxM
                var = Kss - v.T.mm(v)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._index_channel(self.likelihood.variance(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - v.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.variance(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class Snelson(Model):
    # See:
    #  E. Snelson, Z. Ghahramani, &#34;Sparse Gaussian Processes using Pseudo-inputs&#34;, 2005
    def __init__(self, kernel, X, y, Z=10, variance=1.0, jitter=1e-8, mean=None, name=&#34;Snelson&#34;):
        if 1 &lt; kernel.output_dims:
            # turn on Gaussian likelihood variance per channel
            variance = Parameter([variance] * kernel.output_dims, name=&#34;variance&#34;, lower=config.positive_minimum)
        else:
            variance = Parameter(variance, name=&#34;variance&#34;, lower=config.positive_minimum)

        super().__init__(kernel, X, y, GaussianLikelihood(variance), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, kernel)
        Z = self._check_input(Z)
        
        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)

        self._register_parameters(self.Z)

    def log_marginal_likelihood(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel.K(self.Z(),self.X)  # MxN
        Kuu = self.kernel.K(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Luu = Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.variance(), self.X)  # N;  diag(Kff-Qff) + sigma^2.I
        G = torch.diagflat(1.0/g)  # N
        L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= 0.5*g.log().sum()
        p -= 0.5*y.T.mm(G).mm(y).squeeze()
        p += 0.5*c.T.mm(c).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff_diag = self.kernel.K_diag(self.X)  # N
            Kuf = self.kernel.K(self.Z(),self.X)  # MxN
            Kuu = self.kernel.K(self.Z())  # MxM
            Kus = self.kernel.K(self.Z(),Xs)  # MxS

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.variance(), self.X)
            G = torch.diagflat(1.0/g)  # N
            L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxM
            b = torch.linalg.solve_triangular(L,a,upper=False)
            c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(w) + b.T.mm(u)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._select_channel(self.likelihood.variance(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.variance(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class OpperArchambeau(Model):
    # See:
    #  M. Opper, C. Archambeau, &#34;The Variational Gaussian Approximation Revisited&#34;, 2009
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(variance=1.0),
                 jitter=1e-8, mean=None, name=&#34;OpperArchambeau&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        if likelihood.output_dims != 1 and likelihood.output_dims != kernel.output_dims:
            raise ValueError(&#34;kernel and likelihood must have matching output dimensions&#34;)
        likelihood.validate_y(y)

        n = self.X.shape[0]
        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.q_nu = Parameter(torch.zeros(n,1), name=&#34;q_nu&#34;)
        self.q_lambda = Parameter(torch.ones(n,1), name=&#34;q_lambda&#34;, lower=config.positive_minimum)
        self.likelihood = likelihood

        self._register_parameters(self.q_nu)
        self._register_parameters(self.q_lambda)

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        q_nu = self.q_nu()  # Nx1
        q_lambda = self.q_lambda()

        Kff = self.kernel(self.X)  # NxN
        L = self._cholesky(q_lambda*q_lambda.T*Kff + self.eye)
        invL = torch.linalg.solve_triangular(L,self.eye,upper=False)  # NxN

        qf_mu = Kff.mm(q_nu)
        qf_var_diag = (1.0/q_lambda.square()) - (invL.T.mm(invL)/q_lambda/q_lambda.T).diagonal().reshape(-1,1)
        if self.mean is not None:
            qf_mu += self.mean(self.X).reshape(-1,1)  # Sx1

        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)

        kl = -q_nu.shape[0]
        kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
        kl += 2.0*L.diagonal().log().sum()  # determinant
        kl += invL.square().sum()  # trace
        return var_exp - 0.5*kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            Kff = self.kernel(self.X)
            Kfs = self.kernel(self.X,Xs)  # NxS

            L = self._cholesky(Kff + (1.0/self.q_lambda()).square().diagflat())  # NxN
            a = torch.linalg.solve_triangular(L,Kfs,upper=False)  # NxS;  Kuu^(-1/2).Kus

            mu = Kfs.T.mm(self.q_nu())  # Sx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if full:
                Kss = self.kernel(Xs)  # SxS
                var = Kss - a.T.mm(a)  # SxS
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1)  # M
                var = var.reshape(-1,1)

            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class Titsias(Model):
    # See:
    #  Titsias, &#34;Variational learning of induced variables in sparse Gaussian processes&#34;, 2009
    #  http://krasserm.github.io/2020/12/12/gaussian-processes-sparse/
    def __init__(self, kernel, X, y, Z, variance=1.0, jitter=1e-8,
                 mean=None, name=&#34;Titsias&#34;):
        # TODO: variance per channel
        super().__init__(kernel, X, y, GaussianLikelihood(variance), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, kernel)
        Z = self._check_input(Z)

        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)

        self._register_parameters(self.Z)

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel(self.Z(),self.X)  # MxN
        Kuu = self.kernel(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        Q = v.mm(v.T)  # MxM;  Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)
        L = self._cholesky(Q/self.likelihood.variance() + self.eye)  # MxM;  (Q/sigma^2 + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.variance()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

        # p = log N(0, Kfu.Kuu^(-1).Kuf + I/sigma^2) - 1/(2.sigma^2).Trace(Kff - Kfu.Kuu^(-1).Kuf)
        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= 0.5*self.X.shape[0]*self.likelihood.variance().log()
        p -= 0.5*y.T.mm(y).squeeze()/self.likelihood.variance()
        p += 0.5*c.T.mm(c).squeeze()
        p -= 0.5*(Kff_diag.sum() - Q.trace())/self.likelihood.variance() # trace
        return p

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kus = self.kernel(self.Z(),Xs)  # MxS
            Kuf = self.kernel(self.Z(),self.X)  # MxN
            Kuu = self.kernel(self.Z())  # MxM

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            L = self._cholesky(v.mm(v.T)/self.likelihood.variance() + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)/sigma^2 + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # MxS;  Kuu^(-1/2).Kus
            b = torch.linalg.solve_triangular(L,a,upper=False)  # MxS;  L^(-1).Kuu^(-1/2).Kus
            c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.variance()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

            # mu = sigma^(-2).Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kuf.y
            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            # var = Kss - Qsf.(Qff + sigma^2 I)^(-1).Qfs
            # below is the equivalent but more stable version by using the matrix inversion lemma
            # var = Kss - Ksu.Kuu^(-1).Kus + Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kus
            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(a) + b.T.mm(b)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self.likelihood.variance() * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self.likelihood.variance()
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class SparseHensman(Model):
    # See:
    #  J. Hensman, et al., &#34;Scalable Variational Gaussian Process Classification&#34;, 2015
    # This version replaces mu_q by L.mu_q and sigma_q by L.sigma_q.L^T, where LL^T = Kuu
    # So that p(u) ~ N(0,1) and q(u) ~ N(L.mu_q, L.sigma_q.L^T)
    def __init__(self, kernel, X, y, Z=None, likelihood=GaussianLikelihood(variance=1.0),
                 jitter=1e-8, mean=None, name=&#34;SparseHensman&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        n = self.X.shape[0]
        self.is_sparse = Z is not None
        if self.is_sparse:
            Z = init_inducing_points(Z, self.X, kernel)
            Z = self._check_input(Z)
            n = Z.shape[0]

        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.q_mu = Parameter(torch.zeros(n,1), name=&#34;q_mu&#34;)
        self.q_sqrt = Parameter(torch.eye(n), name=&#34;q_sqrt&#34;)
        if self.is_sparse:
            self.Z = Parameter(Z, name=&#34;induction_points&#34;)
        else:
            self.Z = Parameter(self.X, trainable=False)  # don&#39;t use inducing points

        self._register_parameters(self.q_mu)
        self._register_parameters(self.q_sqrt)
        if self.is_sparse:
            self._register_parameters(self.Z)

    def kl_gaussian(self, q_mu, q_sqrt):
        Lq = q_sqrt.tril() # NxN
        kl = -q_mu.shape[0]
        kl += q_mu.T.mm(q_mu).squeeze()  # Mahalanobis
        kl -= Lq.diagonal().square().log().sum()  # determinant of q_var
        kl += Lq.square().sum()  # same as Trace(p_var^(-1).q_var)
        return 0.5*kl

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        if self.is_sparse:
            qf_mu, qf_var_diag = self._predict(self.X, full=False)
        else:
            Kff = self.kernel(self.X)
            Lff = self._cholesky(Kff, add_jitter=True)  # NxN

            qf_mu = Lff.mm(self.q_mu())
            if self.mean is not None:
                qf_mu += self.mean(self.X).reshape(-1,1)  # Sx1

            qf_sqrt = Lff.mm(self.q_sqrt().tril())
            qf_var_diag = qf_sqrt.mm(qf_sqrt.T).diagonal().reshape(-1,1)

        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)
        kl = self.kl_gaussian(self.q_mu(), self.q_sqrt())
        return var_exp - kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def _predict(self, Xs, full=False):
        Kuu = self.kernel(self.Z())
        Kus = self.kernel(self.Z(),Xs)  # NxS

        Luu = self._cholesky(Kuu, add_jitter=True)  # NxN
        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxS;  Kuu^(-1/2).Kus
        b = self.q_sqrt().tril().T.mm(torch.linalg.solve_triangular(Luu,Kus,upper=False))

        mu = Kus.T.mm(torch.linalg.solve_triangular(Luu.T,self.q_mu(),upper=True))  # Sx1
        if full:
            Kss = self.kernel(Xs)  # SxS
            var = Kss - a.T.mm(a) + b.T.mm(b)  # SxS
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            var = var.reshape(-1,1)
        return mu, var

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            mu, var = self._predict(Xs, full=full and not predict_y)
            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class Hensman(SparseHensman):
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(variance=1.0), jitter=1e-8,
                 mean=None, name=&#34;Hensman&#34;):
        super().__init__(kernel, X, y, None, likelihood, jitter, mean, name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mogptk.gpr.model.init_inducing_points"><code class="name flex">
<span>def <span class="ident">init_inducing_points</span></span>(<span>Z, X, kernel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L12-L34" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init_inducing_points(Z, X, kernel):
    # TODO: instead of linspace, use quantile space or k-means to initialize positions
    output_dims = kernel.output_dims
    if 1 &lt; output_dims:
        if isinstance(Z, int) or all(isinstance(z, int) for z in Z) and len(Z) == output_dims:
            if isinstance(Z, int):
                Z = [Z] * output_dims
            M = Z
            Z = torch.zeros((sum(M),X.shape[1]))
            for j in range(len(M)):
                m0 = sum(M[:j])
                m = M[j]
                Z[m0:m0+m,0] = j
                for i in range(X.shape[1])[1:]:
                    x = X[X[:,0] == j,:]
                    Z[m0:m0+m,i] = torch.linspace(torch.min(x[:,i]), torch.max(x[:,i]), m)
    elif isinstance(Z, int):
        M = Z
        Z = torch.zeros((M,X.shape[1]))
        # TODO: this puts values &#34;diagonal&#34;, better to use grid?
        for i in range(X.shape[1]):
            Z[:,i] = torch.linspace(torch.min(X[:,i]), torch.max(X[:,i]), M)
    return Z</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.prod"><code class="name flex">
<span>def <span class="ident">prod</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L9-L10" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def prod(iterable):
    return reduce(operator.mul, iterable, 1)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mogptk.gpr.model.CholeskyException"><code class="flex name class">
<span>class <span class="ident">CholeskyException</span></span>
<span>(</span><span>message, K, model)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L36-L43" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CholeskyException(Exception):
    def __init__(self, message, K, model):
        self.message = message
        self.K = K
        self.model = model

    def __str__(self):
        return self.message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Exact"><code class="flex name class">
<span>class <span class="ident">Exact</span></span>
<span>(</span><span>kernel, X, y, variance=1.0, jitter=1e-08, mean=None, name='Exact')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L271-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Exact(Model):
    def __init__(self, kernel, X, y, variance=1.0, jitter=1e-8, mean=None, name=&#34;Exact&#34;):
        # turn on Gaussian likelihood variance per channel and or per data point
        # variance shape will be (channels,data_points), where if either is unity, the variance will be equal amonst all channels or data points respectively
        variance = Parameter.to_tensor(variance).squeeze()
        if variance.ndim == 1 and 0 &lt; X.ndim and variance.shape[0] == X.shape[0]:
            variance = variance.reshape(1,-1)
        elif variance.ndim == 0 or variance.ndim == 1 and variance.shape[0] == 1:
            variance = variance.repeat(kernel.output_dims)
        elif variance.ndim != 1 or variance.shape[0] != kernel.output_dims:
            raise ValueError(&#34;variance must have shape (channels,) or (data_points,)&#34;)

        super().__init__(kernel, X, y, GaussianLikelihood(variance), jitter, mean, name)
        self.likelihood.variance.trainable = variance.ndim == 1

        self.eye = torch.eye(self.X.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)

    def log_marginal_likelihood(self):
        Kff = self.kernel.K(self.X)
        if self.likelihood.variance().ndim == 2:
            Kff += self.likelihood.variance()[0,:].diagflat()
        else:
            Kff += self._index_channel(self.likelihood.variance(), self.X) * self.eye  # NxN
        L = self._cholesky(Kff, add_jitter=True)  # NxN

        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken inside the log: L is the square root
        p -= 0.5*y.T.mm(torch.cholesky_solve(y,L)).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        if self.likelihood.variance().ndim == 2 and predict_y:
            raise ValueError(&#34;can only predict f when data point variances are given, set predict_y=False&#34;)

        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff = self.kernel.K(self.X)
            if self.likelihood.variance().ndim == 2:
                Kff += self.likelihood.variance()[0,:].diagflat()
            else:
                Kff += self._index_channel(self.likelihood.variance(), self.X) * self.eye  # NxN
            Kfs = self.kernel.K(self.X,Xs)  # NxM

            Lff = self._cholesky(Kff, add_jitter=True)  # NxN
            v = torch.linalg.solve_triangular(Lff,Kfs,upper=False)  # NxM

            mu = Kfs.T.mm(torch.cholesky_solve(y,Lff))  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel.K(Xs)  # MxM
                var = Kss - v.T.mm(v)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._index_channel(self.likelihood.variance(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - v.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.variance(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Exact.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L289-L305" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    Kff = self.kernel.K(self.X)
    if self.likelihood.variance().ndim == 2:
        Kff += self.likelihood.variance()[0,:].diagflat()
    else:
        Kff += self._index_channel(self.likelihood.variance(), self.X) * self.eye  # NxN
    L = self._cholesky(Kff, add_jitter=True)  # NxN

    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    p = -self.log_marginal_likelihood_constant
    p -= L.diagonal().log().sum() # 0.5 is taken inside the log: L is the square root
    p -= 0.5*y.T.mm(torch.cholesky_solve(y,L)).squeeze()
    return p</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Exact.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L307-L348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    if self.likelihood.variance().ndim == 2 and predict_y:
        raise ValueError(&#34;can only predict f when data point variances are given, set predict_y=False&#34;)

    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff = self.kernel.K(self.X)
        if self.likelihood.variance().ndim == 2:
            Kff += self.likelihood.variance()[0,:].diagflat()
        else:
            Kff += self._index_channel(self.likelihood.variance(), self.X) * self.eye  # NxN
        Kfs = self.kernel.K(self.X,Xs)  # NxM

        Lff = self._cholesky(Kff, add_jitter=True)  # NxN
        v = torch.linalg.solve_triangular(Lff,Kfs,upper=False)  # NxM

        mu = Kfs.T.mm(torch.cholesky_solve(y,Lff))  # Mx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Mx1

        if full:
            Kss = self.kernel.K(Xs)  # MxM
            var = Kss - v.T.mm(v)  # MxM
            if predict_y:
                eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                var += self._index_channel(self.likelihood.variance(), Xs) * eye
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - v.T.square().sum(dim=1)  # M
            if predict_y:
                var += self._index_channel(self.likelihood.variance(), Xs)
            var = var.reshape(-1,1)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mogptk.gpr.model.Hensman"><code class="flex name class">
<span>class <span class="ident">Hensman</span></span>
<span>(</span><span>kernel, X, y, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name='Hensman')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L713-L716" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Hensman(SparseHensman):
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(variance=1.0), jitter=1e-8,
                 mean=None, name=&#34;Hensman&#34;):
        super().__init__(kernel, X, y, None, likelihood, jitter, mean, name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></li>
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>kernel, X, y, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L45-L269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Model:
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0), jitter=1e-8, mean=None, name=None):
        if not issubclass(type(kernel), Kernel):
            raise ValueError(&#34;kernel must derive from mogptk.gpr.Kernel&#34;)
        X, y = self._check_input(X, y)
        if mean is not None:
            if not issubclass(type(mean), Mean):
                raise ValueError(&#34;mean must derive from mogptk.gpr.Mean&#34;)
            mu = mean(X).reshape(-1,1)
            if mu.shape != y.shape:
                raise ValueError(&#34;mean and y data must match shapes: %s != %s&#34; % (mu.shape, y.shape))

        if likelihood.output_dims != 1 and likelihood.output_dims != kernel.output_dims:
            raise ValueError(&#34;kernel and likelihood must have matching output dimensions&#34;)
        likelihood.validate_y(y)

        # limit to number of significant digits
        if config.dtype == torch.float32:
            jitter = max(jitter, 1e-6)
        elif config.dtype == torch.float64:
            jitter = max(jitter, 1e-15)

        self.kernel = kernel
        self.X = X
        self.y = y
        self.likelihood = likelihood
        self.jitter = jitter
        self.mean = mean
        self.name = name
        self.input_dims = X.shape[1]

        self._params = []
        self._register_parameters(kernel)
        self._register_parameters(likelihood)
        if mean is not None and issubclass(type(mean), Mean):
            self._register_parameters(mean)

    def __setattr__(self, name, val):
        if hasattr(self, name) and isinstance(getattr(self, name), Parameter):
            raise AttributeError(&#34;parameter is read-only, use Parameter.assign()&#34;)
        super().__setattr__(name, val)        

    def _check_input(self, X, y=None):
        if not isinstance(X, torch.Tensor):
            X = torch.tensor(X, device=config.device, dtype=config.dtype)
        else:
            X = X.to(config.device, config.dtype)
        if X.ndim == 0:
            X = X.reshape(1,1)
        elif X.ndim == 1:
            X = X.reshape(-1,1)
        elif X.ndim != 2:
            raise ValueError(&#34;X must have dimensions (data_points,input_dims) with input_dims optional&#34;)
        if X.shape[0] == 0 or X.shape[1] == 0:
            raise ValueError(&#34;X must not be empty&#34;)

        if y is not None:
            if not isinstance(y, torch.Tensor):
                y = torch.tensor(y, device=config.device, dtype=config.dtype)
            else:
                y = y.to(config.device, config.dtype)
            if y.ndim == 0:
                y = y.reshape(1,1)
            elif y.ndim == 1:
                y = y.reshape(-1,1)
            elif y.ndim != 2 or y.shape[1] != 1:
                raise ValueError(&#34;y must have one dimension (data_points,)&#34;)
            if X.shape[0] != y.shape[0]:
                raise ValueError(&#34;number of data points for X and y must match&#34;)
            return X, y
        else:
            # X is for prediction
            if X.shape[1] != self.input_dims:
                raise ValueError(&#34;X must have %s input dimensions&#34; % self.input_dims)
            return X

    def _index_channel(self, value, X):
        if 1 &lt; self.kernel.output_dims and 0 &lt; value.ndim and value.shape[0] == self.kernel.output_dims:
            return torch.index_select(value, dim=0, index=X[:,0].long())
        return value

    def _register_parameters(self, obj, name=None):
        if isinstance(obj, Parameter):
            if obj.name is not None:
                if name is None:
                    name = obj.name
                else:
                    name += &#34;.&#34; + obj.name
            elif name is None:
                name = &#34;&#34;
            obj.name = name
            self._params.append(obj)
        elif isinstance(obj, list):
            for i, v in enumerate(obj):
                self._register_parameters(v, (name if name is not None else &#34;&#34;)+&#34;[&#34;+str(i)+&#34;]&#34;)
        elif issubclass(type(obj), (Kernel, Mean, Likelihood)):
            for v in obj.__dict__.values():
                self._register_parameters(v, (name+&#34;.&#34; if name is not None else &#34;&#34;)+obj.name)

    def zero_grad(self):
        for p in self._params:
            p = p.unconstrained
            if p.grad is not None:
                if p.grad.grad_fn is not None:
                    p.grad.detach_()
                else:
                    p.grad.requires_grad_(False)
                p.grad.zero_()

    def parameters(self):
        for p in self._params:
            if p.trainable:
                yield p.unconstrained

    def get_parameters(self):
        return self._params
    
    def print_parameters(self, file=None):
        def param_range(lower, upper, trainable=True, pegged=False):
            if lower is not None:
                if prod(lower.shape) == 1:
                    lower = lower.item()
                else:
                    lower = lower.tolist()
            if upper is not None:
                if prod(upper.shape) == 1:
                    upper = upper.item()
                else:
                    upper = upper.tolist()

            if pegged:
                return &#34;pegged&#34;
            elif not trainable:
                return &#34;fixed&#34;
            if lower is None and upper is None:
                return &#34;(-∞, ∞)&#34;
            elif lower is None:
                return &#34;(-∞, %s]&#34; % upper
            elif upper is None:
                return &#34;[%s, ∞)&#34; % lower
            return &#34;[%s, %s]&#34; % (lower, upper)

        if file is None:
            try:
                get_ipython  # fails if we&#39;re not in a notebook
                table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;&lt;th&gt;Range&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
                for p in self._params:
                    table += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (p.name, param_range(p.lower, p.upper, p.trainable, p.pegged), p.numpy())
                table += &#39;&lt;/table&gt;&#39;
                display(HTML(table))
                return
            except Exception as e:
                pass

        vals = [[&#34;Name&#34;, &#34;Range&#34;, &#34;Value&#34;]]
        for p in self._params:
            vals.append([p.name, param_range(p.lower, p.upper, p.trainable, p.pegged), str(p.numpy())])

        nameWidth = max([len(val[0]) for val in vals])
        rangeWidth = max([len(val[1]) for val in vals])
        for val in vals:
            print(&#34;%-*s  %-*s  %s&#34; % (nameWidth, val[0], rangeWidth, val[1], val[2]), file=file)

    def _cholesky(self, K, add_jitter=False):
        if add_jitter:
            K += (self.jitter * K.diagonal().mean()).repeat(K.shape[0]).diagflat()
        try:
            return torch.linalg.cholesky(K)
        except RuntimeError as e:
            print(&#34;ERROR:&#34;, e.args[0], file=sys.__stdout__)
            if K.isnan().any():
                print(&#34;ERROR: kernel matrix has NaNs!&#34;, file=sys.__stdout__)
            if K.isinf().any():
                print(&#34;ERROR: kernel matrix has infinities!&#34;, file=sys.__stdout__)
            self.print_parameters()
            plot_gram(K)
            raise CholeskyException(e.args[0], K, self)

    def log_marginal_likelihood(self):
        raise NotImplementedError()

    def log_prior(self):
        return sum([p.log_prior() for p in self._params])

    def loss(self):
        self.zero_grad()
        loss = -self.log_marginal_likelihood() - self.log_prior()
        loss.backward()
        return loss

    def K(self, X1, X2=None):
        with torch.no_grad():
            return self.kernel(X1, X2).cpu().numpy() # does cpu().numpy() detach? check memory usage

    def quantile(self, p, mu, var):
        with torch.no_grad():
            if not isinstance(p, torch.Tensor):
                p = torch.tensor(p, device=config.device, dtype=config.dtype)
            else:
                p = p.to(config.device, config.dtype)
            p = p.squeeze()
            if p.ndim != 0:
                raise ValueError(&#34;quantile must be scalar&#34;)
            return self.likelihood.quantile(p, mu, var)

    def sample(self, Z, n=None, predict_y=True):
        with torch.no_grad():
            S = n
            if n is None:
                S = 1

            # TODO: predict_y and non-Gaussian likelihoods
            mu, var = self.predict(Z, full=True, tensor=True, predict_y=predict_y)  # MxD and MxMxD
            eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
            var += self.jitter * var.diagonal().mean() * eye  # MxM

            u = torch.normal(
                    torch.zeros(Z.shape[0], S, device=config.device, dtype=config.dtype),
                    torch.tensor(1.0, device=config.device, dtype=config.dtype))  # MxS
            L = torch.linalg.cholesky(var)  # MxM
            samples = mu + L.mm(u)  # MxS

            if n is None:
                samples = samples.squeeze()
            return samples.cpu().numpy()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Exact" href="#mogptk.gpr.model.Exact">Exact</a></li>
<li><a title="mogptk.gpr.model.OpperArchambeau" href="#mogptk.gpr.model.OpperArchambeau">OpperArchambeau</a></li>
<li><a title="mogptk.gpr.model.Snelson" href="#mogptk.gpr.model.Snelson">Snelson</a></li>
<li><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></li>
<li><a title="mogptk.gpr.model.Titsias" href="#mogptk.gpr.model.Titsias">Titsias</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Model.K"><code class="name flex">
<span>def <span class="ident">K</span></span>(<span>self, X1, X2=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L235-L237" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def K(self, X1, X2=None):
    with torch.no_grad():
        return self.kernel(X1, X2).cpu().numpy() # does cpu().numpy() detach? check memory usage</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.get_parameters"><code class="name flex">
<span>def <span class="ident">get_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L159-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_parameters(self):
    return self._params</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L223-L224" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.log_prior"><code class="name flex">
<span>def <span class="ident">log_prior</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L226-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_prior(self):
    return sum([p.log_prior() for p in self._params])</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.loss"><code class="name flex">
<span>def <span class="ident">loss</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L229-L233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loss(self):
    self.zero_grad()
    loss = -self.log_marginal_likelihood() - self.log_prior()
    loss.backward()
    return loss</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.parameters"><code class="name flex">
<span>def <span class="ident">parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L154-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parameters(self):
    for p in self._params:
        if p.trainable:
            yield p.unconstrained</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.print_parameters"><code class="name flex">
<span>def <span class="ident">print_parameters</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L162-L206" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print_parameters(self, file=None):
    def param_range(lower, upper, trainable=True, pegged=False):
        if lower is not None:
            if prod(lower.shape) == 1:
                lower = lower.item()
            else:
                lower = lower.tolist()
        if upper is not None:
            if prod(upper.shape) == 1:
                upper = upper.item()
            else:
                upper = upper.tolist()

        if pegged:
            return &#34;pegged&#34;
        elif not trainable:
            return &#34;fixed&#34;
        if lower is None and upper is None:
            return &#34;(-∞, ∞)&#34;
        elif lower is None:
            return &#34;(-∞, %s]&#34; % upper
        elif upper is None:
            return &#34;[%s, ∞)&#34; % lower
        return &#34;[%s, %s]&#34; % (lower, upper)

    if file is None:
        try:
            get_ipython  # fails if we&#39;re not in a notebook
            table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;&lt;th&gt;Range&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
            for p in self._params:
                table += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (p.name, param_range(p.lower, p.upper, p.trainable, p.pegged), p.numpy())
            table += &#39;&lt;/table&gt;&#39;
            display(HTML(table))
            return
        except Exception as e:
            pass

    vals = [[&#34;Name&#34;, &#34;Range&#34;, &#34;Value&#34;]]
    for p in self._params:
        vals.append([p.name, param_range(p.lower, p.upper, p.trainable, p.pegged), str(p.numpy())])

    nameWidth = max([len(val[0]) for val in vals])
    rangeWidth = max([len(val[1]) for val in vals])
    for val in vals:
        print(&#34;%-*s  %-*s  %s&#34; % (nameWidth, val[0], rangeWidth, val[1], val[2]), file=file)</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.quantile"><code class="name flex">
<span>def <span class="ident">quantile</span></span>(<span>self, p, mu, var)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L239-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def quantile(self, p, mu, var):
    with torch.no_grad():
        if not isinstance(p, torch.Tensor):
            p = torch.tensor(p, device=config.device, dtype=config.dtype)
        else:
            p = p.to(config.device, config.dtype)
        p = p.squeeze()
        if p.ndim != 0:
            raise ValueError(&#34;quantile must be scalar&#34;)
        return self.likelihood.quantile(p, mu, var)</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, Z, n=None, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L250-L269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, Z, n=None, predict_y=True):
    with torch.no_grad():
        S = n
        if n is None:
            S = 1

        # TODO: predict_y and non-Gaussian likelihoods
        mu, var = self.predict(Z, full=True, tensor=True, predict_y=predict_y)  # MxD and MxMxD
        eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
        var += self.jitter * var.diagonal().mean() * eye  # MxM

        u = torch.normal(
                torch.zeros(Z.shape[0], S, device=config.device, dtype=config.dtype),
                torch.tensor(1.0, device=config.device, dtype=config.dtype))  # MxS
        L = torch.linalg.cholesky(var)  # MxM
        samples = mu + L.mm(u)  # MxS

        if n is None:
            samples = samples.squeeze()
        return samples.cpu().numpy()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.zero_grad"><code class="name flex">
<span>def <span class="ident">zero_grad</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L144-L152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zero_grad(self):
    for p in self._params:
        p = p.unconstrained
        if p.grad is not None:
            if p.grad.grad_fn is not None:
                p.grad.detach_()
            else:
                p.grad.requires_grad_(False)
            p.grad.zero_()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mogptk.gpr.model.OpperArchambeau"><code class="flex name class">
<span>class <span class="ident">OpperArchambeau</span></span>
<span>(</span><span>kernel, X, y, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name='OpperArchambeau')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L441-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OpperArchambeau(Model):
    # See:
    #  M. Opper, C. Archambeau, &#34;The Variational Gaussian Approximation Revisited&#34;, 2009
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(variance=1.0),
                 jitter=1e-8, mean=None, name=&#34;OpperArchambeau&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        if likelihood.output_dims != 1 and likelihood.output_dims != kernel.output_dims:
            raise ValueError(&#34;kernel and likelihood must have matching output dimensions&#34;)
        likelihood.validate_y(y)

        n = self.X.shape[0]
        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.q_nu = Parameter(torch.zeros(n,1), name=&#34;q_nu&#34;)
        self.q_lambda = Parameter(torch.ones(n,1), name=&#34;q_lambda&#34;, lower=config.positive_minimum)
        self.likelihood = likelihood

        self._register_parameters(self.q_nu)
        self._register_parameters(self.q_lambda)

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        q_nu = self.q_nu()  # Nx1
        q_lambda = self.q_lambda()

        Kff = self.kernel(self.X)  # NxN
        L = self._cholesky(q_lambda*q_lambda.T*Kff + self.eye)
        invL = torch.linalg.solve_triangular(L,self.eye,upper=False)  # NxN

        qf_mu = Kff.mm(q_nu)
        qf_var_diag = (1.0/q_lambda.square()) - (invL.T.mm(invL)/q_lambda/q_lambda.T).diagonal().reshape(-1,1)
        if self.mean is not None:
            qf_mu += self.mean(self.X).reshape(-1,1)  # Sx1

        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)

        kl = -q_nu.shape[0]
        kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
        kl += 2.0*L.diagonal().log().sum()  # determinant
        kl += invL.square().sum()  # trace
        return var_exp - 0.5*kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            Kff = self.kernel(self.X)
            Kfs = self.kernel(self.X,Xs)  # NxS

            L = self._cholesky(Kff + (1.0/self.q_lambda()).square().diagflat())  # NxN
            a = torch.linalg.solve_triangular(L,Kfs,upper=False)  # NxS;  Kuu^(-1/2).Kus

            mu = Kfs.T.mm(self.q_nu())  # Sx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if full:
                Kss = self.kernel(Xs)  # SxS
                var = Kss - a.T.mm(a)  # SxS
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1)  # M
                var = var.reshape(-1,1)

            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.OpperArchambeau.elbo"><code class="name flex">
<span>def <span class="ident">elbo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L461-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elbo(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    q_nu = self.q_nu()  # Nx1
    q_lambda = self.q_lambda()

    Kff = self.kernel(self.X)  # NxN
    L = self._cholesky(q_lambda*q_lambda.T*Kff + self.eye)
    invL = torch.linalg.solve_triangular(L,self.eye,upper=False)  # NxN

    qf_mu = Kff.mm(q_nu)
    qf_var_diag = (1.0/q_lambda.square()) - (invL.T.mm(invL)/q_lambda/q_lambda.T).diagonal().reshape(-1,1)
    if self.mean is not None:
        qf_mu += self.mean(self.X).reshape(-1,1)  # Sx1

    var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)

    kl = -q_nu.shape[0]
    kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
    kl += 2.0*L.diagonal().log().sum()  # determinant
    kl += invL.square().sum()  # trace
    return var_exp - 0.5*kl</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.OpperArchambeau.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L487-L489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    # maximize the lower bound
    return self.elbo()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.OpperArchambeau.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L491-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD

        Kff = self.kernel(self.X)
        Kfs = self.kernel(self.X,Xs)  # NxS

        L = self._cholesky(Kff + (1.0/self.q_lambda()).square().diagflat())  # NxN
        a = torch.linalg.solve_triangular(L,Kfs,upper=False)  # NxS;  Kuu^(-1/2).Kus

        mu = Kfs.T.mm(self.q_nu())  # Sx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Sx1

        if full:
            Kss = self.kernel(Xs)  # SxS
            var = Kss - a.T.mm(a)  # SxS
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1)  # M
            var = var.reshape(-1,1)

        if predict_y:
            mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mogptk.gpr.model.Snelson"><code class="flex name class">
<span>class <span class="ident">Snelson</span></span>
<span>(</span><span>kernel, X, y, Z=10, variance=1.0, jitter=1e-08, mean=None, name='Snelson')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L350-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Snelson(Model):
    # See:
    #  E. Snelson, Z. Ghahramani, &#34;Sparse Gaussian Processes using Pseudo-inputs&#34;, 2005
    def __init__(self, kernel, X, y, Z=10, variance=1.0, jitter=1e-8, mean=None, name=&#34;Snelson&#34;):
        if 1 &lt; kernel.output_dims:
            # turn on Gaussian likelihood variance per channel
            variance = Parameter([variance] * kernel.output_dims, name=&#34;variance&#34;, lower=config.positive_minimum)
        else:
            variance = Parameter(variance, name=&#34;variance&#34;, lower=config.positive_minimum)

        super().__init__(kernel, X, y, GaussianLikelihood(variance), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, kernel)
        Z = self._check_input(Z)
        
        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)

        self._register_parameters(self.Z)

    def log_marginal_likelihood(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel.K(self.Z(),self.X)  # MxN
        Kuu = self.kernel.K(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Luu = Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.variance(), self.X)  # N;  diag(Kff-Qff) + sigma^2.I
        G = torch.diagflat(1.0/g)  # N
        L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= 0.5*g.log().sum()
        p -= 0.5*y.T.mm(G).mm(y).squeeze()
        p += 0.5*c.T.mm(c).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff_diag = self.kernel.K_diag(self.X)  # N
            Kuf = self.kernel.K(self.Z(),self.X)  # MxN
            Kuu = self.kernel.K(self.Z())  # MxM
            Kus = self.kernel.K(self.Z(),Xs)  # MxS

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.variance(), self.X)
            G = torch.diagflat(1.0/g)  # N
            L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxM
            b = torch.linalg.solve_triangular(L,a,upper=False)
            c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(w) + b.T.mm(u)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._select_channel(self.likelihood.variance(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.variance(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Snelson.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L371-L394" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    Kff_diag = self.kernel.K_diag(self.X)  # N
    Kuf = self.kernel.K(self.Z(),self.X)  # MxN
    Kuu = self.kernel.K(self.Z())  # MxM

    Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Luu = Kuu^(1/2)
    v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
    g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.variance(), self.X)  # N;  diag(Kff-Qff) + sigma^2.I
    G = torch.diagflat(1.0/g)  # N
    L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

    c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

    p = -self.log_marginal_likelihood_constant
    p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
    p -= 0.5*g.log().sum()
    p -= 0.5*y.T.mm(G).mm(y).squeeze()
    p += 0.5*c.T.mm(c).squeeze()
    return p</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Snelson.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L396-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel.K(self.Z(),self.X)  # MxN
        Kuu = self.kernel.K(self.Z())  # MxM
        Kus = self.kernel.K(self.Z(),Xs)  # MxS

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.variance(), self.X)
        G = torch.diagflat(1.0/g)  # N
        L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxM
        b = torch.linalg.solve_triangular(L,a,upper=False)
        c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

        mu = b.T.mm(c)  # Mx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Mx1

        if full:
            Kss = self.kernel(Xs)  # MxM
            var = Kss - a.T.mm(w) + b.T.mm(u)  # MxM
            if predict_y:
                eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                var += self._select_channel(self.likelihood.variance(), Xs) * eye
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            if predict_y:
                var += self._index_channel(self.likelihood.variance(), Xs)
            var = var.reshape(-1,1)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mogptk.gpr.model.SparseHensman"><code class="flex name class">
<span>class <span class="ident">SparseHensman</span></span>
<span>(</span><span>kernel, X, y, Z=None, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name='SparseHensman')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L615-L711" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SparseHensman(Model):
    # See:
    #  J. Hensman, et al., &#34;Scalable Variational Gaussian Process Classification&#34;, 2015
    # This version replaces mu_q by L.mu_q and sigma_q by L.sigma_q.L^T, where LL^T = Kuu
    # So that p(u) ~ N(0,1) and q(u) ~ N(L.mu_q, L.sigma_q.L^T)
    def __init__(self, kernel, X, y, Z=None, likelihood=GaussianLikelihood(variance=1.0),
                 jitter=1e-8, mean=None, name=&#34;SparseHensman&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        n = self.X.shape[0]
        self.is_sparse = Z is not None
        if self.is_sparse:
            Z = init_inducing_points(Z, self.X, kernel)
            Z = self._check_input(Z)
            n = Z.shape[0]

        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.q_mu = Parameter(torch.zeros(n,1), name=&#34;q_mu&#34;)
        self.q_sqrt = Parameter(torch.eye(n), name=&#34;q_sqrt&#34;)
        if self.is_sparse:
            self.Z = Parameter(Z, name=&#34;induction_points&#34;)
        else:
            self.Z = Parameter(self.X, trainable=False)  # don&#39;t use inducing points

        self._register_parameters(self.q_mu)
        self._register_parameters(self.q_sqrt)
        if self.is_sparse:
            self._register_parameters(self.Z)

    def kl_gaussian(self, q_mu, q_sqrt):
        Lq = q_sqrt.tril() # NxN
        kl = -q_mu.shape[0]
        kl += q_mu.T.mm(q_mu).squeeze()  # Mahalanobis
        kl -= Lq.diagonal().square().log().sum()  # determinant of q_var
        kl += Lq.square().sum()  # same as Trace(p_var^(-1).q_var)
        return 0.5*kl

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        if self.is_sparse:
            qf_mu, qf_var_diag = self._predict(self.X, full=False)
        else:
            Kff = self.kernel(self.X)
            Lff = self._cholesky(Kff, add_jitter=True)  # NxN

            qf_mu = Lff.mm(self.q_mu())
            if self.mean is not None:
                qf_mu += self.mean(self.X).reshape(-1,1)  # Sx1

            qf_sqrt = Lff.mm(self.q_sqrt().tril())
            qf_var_diag = qf_sqrt.mm(qf_sqrt.T).diagonal().reshape(-1,1)

        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)
        kl = self.kl_gaussian(self.q_mu(), self.q_sqrt())
        return var_exp - kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def _predict(self, Xs, full=False):
        Kuu = self.kernel(self.Z())
        Kus = self.kernel(self.Z(),Xs)  # NxS

        Luu = self._cholesky(Kuu, add_jitter=True)  # NxN
        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxS;  Kuu^(-1/2).Kus
        b = self.q_sqrt().tril().T.mm(torch.linalg.solve_triangular(Luu,Kus,upper=False))

        mu = Kus.T.mm(torch.linalg.solve_triangular(Luu.T,self.q_mu(),upper=True))  # Sx1
        if full:
            Kss = self.kernel(Xs)  # SxS
            var = Kss - a.T.mm(a) + b.T.mm(b)  # SxS
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            var = var.reshape(-1,1)
        return mu, var

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            mu, var = self._predict(Xs, full=full and not predict_y)
            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Hensman" href="#mogptk.gpr.model.Hensman">Hensman</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.SparseHensman.elbo"><code class="name flex">
<span>def <span class="ident">elbo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L653-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elbo(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    if self.is_sparse:
        qf_mu, qf_var_diag = self._predict(self.X, full=False)
    else:
        Kff = self.kernel(self.X)
        Lff = self._cholesky(Kff, add_jitter=True)  # NxN

        qf_mu = Lff.mm(self.q_mu())
        if self.mean is not None:
            qf_mu += self.mean(self.X).reshape(-1,1)  # Sx1

        qf_sqrt = Lff.mm(self.q_sqrt().tril())
        qf_var_diag = qf_sqrt.mm(qf_sqrt.T).diagonal().reshape(-1,1)

    var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)
    kl = self.kl_gaussian(self.q_mu(), self.q_sqrt())
    return var_exp - kl</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.SparseHensman.kl_gaussian"><code class="name flex">
<span>def <span class="ident">kl_gaussian</span></span>(<span>self, q_mu, q_sqrt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L645-L651" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def kl_gaussian(self, q_mu, q_sqrt):
    Lq = q_sqrt.tril() # NxN
    kl = -q_mu.shape[0]
    kl += q_mu.T.mm(q_mu).squeeze()  # Mahalanobis
    kl -= Lq.diagonal().square().log().sum()  # determinant of q_var
    kl += Lq.square().sum()  # same as Trace(p_var^(-1).q_var)
    return 0.5*kl</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.SparseHensman.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L676-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    # maximize the lower bound
    return self.elbo()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.SparseHensman.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L698-L711" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD

        mu, var = self._predict(Xs, full=full and not predict_y)
        if predict_y:
            mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Sx1

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mogptk.gpr.model.Titsias"><code class="flex name class">
<span>class <span class="ident">Titsias</span></span>
<span>(</span><span>kernel, X, y, Z, variance=1.0, jitter=1e-08, mean=None, name='Titsias')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L521-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Titsias(Model):
    # See:
    #  Titsias, &#34;Variational learning of induced variables in sparse Gaussian processes&#34;, 2009
    #  http://krasserm.github.io/2020/12/12/gaussian-processes-sparse/
    def __init__(self, kernel, X, y, Z, variance=1.0, jitter=1e-8,
                 mean=None, name=&#34;Titsias&#34;):
        # TODO: variance per channel
        super().__init__(kernel, X, y, GaussianLikelihood(variance), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, kernel)
        Z = self._check_input(Z)

        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)

        self._register_parameters(self.Z)

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel(self.Z(),self.X)  # MxN
        Kuu = self.kernel(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        Q = v.mm(v.T)  # MxM;  Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)
        L = self._cholesky(Q/self.likelihood.variance() + self.eye)  # MxM;  (Q/sigma^2 + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.variance()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

        # p = log N(0, Kfu.Kuu^(-1).Kuf + I/sigma^2) - 1/(2.sigma^2).Trace(Kff - Kfu.Kuu^(-1).Kuf)
        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= 0.5*self.X.shape[0]*self.likelihood.variance().log()
        p -= 0.5*y.T.mm(y).squeeze()/self.likelihood.variance()
        p += 0.5*c.T.mm(c).squeeze()
        p -= 0.5*(Kff_diag.sum() - Q.trace())/self.likelihood.variance() # trace
        return p

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kus = self.kernel(self.Z(),Xs)  # MxS
            Kuf = self.kernel(self.Z(),self.X)  # MxN
            Kuu = self.kernel(self.Z())  # MxM

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            L = self._cholesky(v.mm(v.T)/self.likelihood.variance() + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)/sigma^2 + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # MxS;  Kuu^(-1/2).Kus
            b = torch.linalg.solve_triangular(L,a,upper=False)  # MxS;  L^(-1).Kuu^(-1/2).Kus
            c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.variance()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

            # mu = sigma^(-2).Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kuf.y
            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            # var = Kss - Qsf.(Qff + sigma^2 I)^(-1).Qfs
            # below is the equivalent but more stable version by using the matrix inversion lemma
            # var = Kss - Ksu.Kuu^(-1).Kus + Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kus
            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(a) + b.T.mm(b)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self.likelihood.variance() * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self.likelihood.variance()
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Titsias.elbo"><code class="name flex">
<span>def <span class="ident">elbo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L539-L563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elbo(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    Kff_diag = self.kernel.K_diag(self.X)  # N
    Kuf = self.kernel(self.Z(),self.X)  # MxN
    Kuu = self.kernel(self.Z())  # MxM

    Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
    v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
    Q = v.mm(v.T)  # MxM;  Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)
    L = self._cholesky(Q/self.likelihood.variance() + self.eye)  # MxM;  (Q/sigma^2 + I)^(1/2)

    c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.variance()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

    # p = log N(0, Kfu.Kuu^(-1).Kuf + I/sigma^2) - 1/(2.sigma^2).Trace(Kff - Kfu.Kuu^(-1).Kuf)
    p = -self.log_marginal_likelihood_constant
    p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
    p -= 0.5*self.X.shape[0]*self.likelihood.variance().log()
    p -= 0.5*y.T.mm(y).squeeze()/self.likelihood.variance()
    p += 0.5*c.T.mm(c).squeeze()
    p -= 0.5*(Kff_diag.sum() - Q.trace())/self.likelihood.variance() # trace
    return p</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Titsias.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L565-L567" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    # maximize the lower bound
    return self.elbo()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Titsias.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/f368a16bfb1504832f678b0335e6773127aade67/mogptk/gpr/model.py#L569-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kus = self.kernel(self.Z(),Xs)  # MxS
        Kuf = self.kernel(self.Z(),self.X)  # MxN
        Kuu = self.kernel(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        L = self._cholesky(v.mm(v.T)/self.likelihood.variance() + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)/sigma^2 + I)^(1/2)

        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # MxS;  Kuu^(-1/2).Kus
        b = torch.linalg.solve_triangular(L,a,upper=False)  # MxS;  L^(-1).Kuu^(-1/2).Kus
        c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.variance()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

        # mu = sigma^(-2).Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kuf.y
        mu = b.T.mm(c)  # Mx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Mx1

        # var = Kss - Qsf.(Qff + sigma^2 I)^(-1).Qfs
        # below is the equivalent but more stable version by using the matrix inversion lemma
        # var = Kss - Ksu.Kuu^(-1).Kus + Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kus
        if full:
            Kss = self.kernel(Xs)  # MxM
            var = Kss - a.T.mm(a) + b.T.mm(b)  # MxM
            if predict_y:
                eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                var += self.likelihood.variance() * eye
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            if predict_y:
                var += self.likelihood.variance()
            var = var.reshape(-1,1)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mogptk.gpr" href="index.html">mogptk.gpr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mogptk.gpr.model.init_inducing_points" href="#mogptk.gpr.model.init_inducing_points">init_inducing_points</a></code></li>
<li><code><a title="mogptk.gpr.model.prod" href="#mogptk.gpr.model.prod">prod</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mogptk.gpr.model.CholeskyException" href="#mogptk.gpr.model.CholeskyException">CholeskyException</a></code></h4>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Exact" href="#mogptk.gpr.model.Exact">Exact</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Exact.log_marginal_likelihood" href="#mogptk.gpr.model.Exact.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Exact.predict" href="#mogptk.gpr.model.Exact.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Hensman" href="#mogptk.gpr.model.Hensman">Hensman</a></code></h4>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.quantile" href="#mogptk.gpr.model.Model.quantile">quantile</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.zero_grad" href="#mogptk.gpr.model.Model.zero_grad">zero_grad</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.OpperArchambeau" href="#mogptk.gpr.model.OpperArchambeau">OpperArchambeau</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.OpperArchambeau.elbo" href="#mogptk.gpr.model.OpperArchambeau.elbo">elbo</a></code></li>
<li><code><a title="mogptk.gpr.model.OpperArchambeau.log_marginal_likelihood" href="#mogptk.gpr.model.OpperArchambeau.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.OpperArchambeau.predict" href="#mogptk.gpr.model.OpperArchambeau.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Snelson" href="#mogptk.gpr.model.Snelson">Snelson</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Snelson.log_marginal_likelihood" href="#mogptk.gpr.model.Snelson.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Snelson.predict" href="#mogptk.gpr.model.Snelson.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.SparseHensman.elbo" href="#mogptk.gpr.model.SparseHensman.elbo">elbo</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.kl_gaussian" href="#mogptk.gpr.model.SparseHensman.kl_gaussian">kl_gaussian</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.log_marginal_likelihood" href="#mogptk.gpr.model.SparseHensman.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.predict" href="#mogptk.gpr.model.SparseHensman.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Titsias" href="#mogptk.gpr.model.Titsias">Titsias</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Titsias.elbo" href="#mogptk.gpr.model.Titsias.elbo">elbo</a></code></li>
<li><code><a title="mogptk.gpr.model.Titsias.log_marginal_likelihood" href="#mogptk.gpr.model.Titsias.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Titsias.predict" href="#mogptk.gpr.model.Titsias.predict">predict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>