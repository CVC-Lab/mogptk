<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mogptk.gpr.model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{display:none;font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mogptk.gpr.model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L1-L898" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import sys
import torch
import numpy as np
from scipy.stats import qmc, gaussian_kde
from IPython.display import display, HTML
from . import Parameter, Mean, Kernel, MultiOutputKernel, Likelihood, MultiOutputLikelihood, GaussianLikelihood, config, plot_gram

def _init_grid(N, X):
    n = np.power(N,1.0/X.shape[1])
    if not n.is_integer():
        raise ValueError(&#34;number of inducing points must equal N = n^%d&#34; % X.shape[1])
    n = int(n)

    Z = torch.empty((N,X.shape[1]))
    grid = torch.meshgrid([torch.linspace(torch.min(X[:,i]), torch.max(X[:,i]), n) for i in range(X.shape[1])])
    for i in range(X.shape[1]):
        Z[:,i] = grid[i].flatten()
    return Z

def _init_random(N, X):
    sampler = qmc.Halton(d=X.shape[1])
    samples = sampler.random(n=N)
    Z = torch.empty((N,X.shape[1]))
    for i in range(X.shape[1]):
        Z[:,i] = torch.min(X[:,i]) + (torch.max(X[:,i])-torch.min(X[:,i]))*samples[:,i]
    return Z

def _init_density(N, X):
    kernel = gaussian_kde(X.T.detach().cpu().numpy(), bw_method=&#39;scott&#39;)
    samples = kernel.resample(N).T
    Z = torch.empty((N,X.shape[1]))
    for i in range(X.shape[1]):
        Z[:,i] = torch.tensor(samples[:,i], device=config.device, dtype=config.dtype)
    return Z

def init_inducing_points(Z, X, method=&#39;grid&#39;, output_dims=None):
    &#34;&#34;&#34;
    Initialize locations for inducing points.

    Args:
        Z (int,list): Number of inducing points. A list of ints of shape (output_dims,) will initialize the specified number of inducing points per output dimension.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        method (str): Method for initialization, can be `grid`, `random`, or `density`.
        output_dims (int): Number of output dimensions. If not None, the first input dimension of the input data must contain the channel IDs.

    Returns:
        torch.tensor: Inducing point locations of shape (data_points,input_dims). In case of multiple output dimensions, the first input dimension will be the channel ID.
    &#34;&#34;&#34;
    _init = _init_grid
    if method == &#39;random&#39;:
        _init = _init_random
    elif method == &#39;density&#39;:
        _init = _init_density

    if output_dims is not None:
        if isinstance(Z, int) or all(isinstance(z, int) for z in Z) and len(Z) == output_dims:
            if isinstance(Z, int):
                Z = [Z] * output_dims
            M = Z
            Z = torch.zeros((sum(M),X.shape[1]))
            for j in range(len(M)):
                m0 = sum(M[:j])
                m = M[j]
                Z[m0:m0+m,0] = j
                Z[m0:m0+m,1:] = _init(m, X[X[:,0] == j,1:])
    elif isinstance(Z, int):
        M = Z
        Z = _init(M, X)
    return Z

class CholeskyException(Exception):
    def __init__(self, message, K, model):
        self.message = message
        self.K = K
        self.model = model

    def __str__(self):
        return self.message

class Model:
    &#34;&#34;&#34;
    Base model class.

    Attributes:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        mean (mogptk.gpr.mean.Mean): Mean.
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0), jitter=1e-8, mean=None, name=None):
        if not issubclass(type(kernel), Kernel):
            raise ValueError(&#34;kernel must derive from mogptk.gpr.Kernel&#34;)
        X, y = self._check_input(X, y)
        if mean is not None:
            if not issubclass(type(mean), Mean):
                raise ValueError(&#34;mean must derive from mogptk.gpr.Mean&#34;)
            mu = mean(X).reshape(-1,1)
            if mu.shape != y.shape:
                raise ValueError(&#34;mean and y data must match shapes: %s != %s&#34; % (mu.shape, y.shape))

        if issubclass(type(likelihood), MultiOutputLikelihood) and likelihood.output_dims != kernel.output_dims:
            raise ValueError(&#34;kernel and likelihood must have matching output dimensions&#34;)
        likelihood.validate_y(y, X=X)

        # limit to number of significant digits
        if config.dtype == torch.float32:
            jitter = max(jitter, 1e-6)
        elif config.dtype == torch.float64:
            jitter = max(jitter, 1e-15)

        self._params = []
        self.kernel = kernel
        self.X = X
        self.y = y
        self.likelihood = likelihood
        self.jitter = jitter
        self.mean = mean
        self.name = name
        self.input_dims = X.shape[1]

    def __setattr__(self, name, val):
        if hasattr(self, name) and isinstance(getattr(self, name), Parameter):
            raise AttributeError(&#34;parameter is read-only, use Parameter.assign()&#34;)
        elif isinstance(val, (Parameter, Kernel, Mean, Likelihood)):
            self._register_parameters(val)
        super().__setattr__(name, val)        

    def _check_input(self, X, y=None):
        if not isinstance(X, torch.Tensor):
            X = torch.tensor(X, device=config.device, dtype=config.dtype)
        else:
            X = X.to(config.device, config.dtype)
        if X.ndim == 0:
            X = X.reshape(1,1)
        elif X.ndim == 1:
            X = X.reshape(-1,1)
        elif X.ndim != 2:
            raise ValueError(&#34;X must have dimensions (data_points,input_dims) with input_dims optional&#34;)
        if X.shape[0] == 0 or X.shape[1] == 0:
            raise ValueError(&#34;X must not be empty&#34;)

        if y is not None:
            if not isinstance(y, torch.Tensor):
                y = torch.tensor(y, device=config.device, dtype=config.dtype)
            else:
                y = y.to(config.device, config.dtype)
            if y.ndim == 0:
                y = y.reshape(1,1)
            elif y.ndim == 1:
                y = y.reshape(-1,1)
            elif y.ndim != 2 or y.shape[1] != 1:
                raise ValueError(&#34;y must have one dimension (data_points,)&#34;)
            if X.shape[0] != y.shape[0]:
                raise ValueError(&#34;number of data points for X and y must match&#34;)
            return X, y
        else:
            # X is for prediction
            if X.shape[1] != self.input_dims:
                raise ValueError(&#34;X must have %s input dimensions&#34; % self.input_dims)
            return X

    def _index_channel(self, value, X):
        if self.kernel.output_dims is not None and 0 &lt; value.ndim and value.shape[0] == self.kernel.output_dims:
            return torch.index_select(value, dim=0, index=X[:,0].long())
        return value

    def _register_parameters(self, obj, name=None):
        if isinstance(obj, Parameter):
            if obj.name is not None:
                if name is None:
                    name = obj.name
                else:
                    name += &#34;.&#34; + obj.name
            elif name is None:
                name = &#34;&#34;
            obj.name = name
            self._params.append(obj)
        elif isinstance(obj, list):
            for i, v in enumerate(obj):
                self._register_parameters(v, (name if name is not None else &#34;&#34;)+&#34;[&#34;+str(i)+&#34;]&#34;)
        elif issubclass(type(obj), (Kernel, Mean, Likelihood)):
            for v in obj.__dict__.values():
                self._register_parameters(v, (name+&#34;.&#34; if name is not None else &#34;&#34;)+obj.name)

    def zero_grad(self):
        for p in self._params:
            p = p.unconstrained
            if p.grad is not None:
                if p.grad.grad_fn is not None:
                    p.grad.detach_()
                else:
                    p.grad.requires_grad_(False)
                p.grad.zero_()

    def parameters(self):
        &#34;&#34;&#34;
        Yield trainable parameters of model.

        Returns:
            Parameter generator
        &#34;&#34;&#34;
        for p in self._params:
            if p.train:
                yield p.unconstrained

    def get_parameters(self):
        &#34;&#34;&#34;
        Return all parameters of model.

        Returns:
            list: List of Parameters.
        &#34;&#34;&#34;
        return self._params
    
    def print_parameters(self, file=None):
        &#34;&#34;&#34;
        Print parameters and their values.
        &#34;&#34;&#34;
        def param_range(lower, upper, train=True, pegged=False):
            if lower is not None:
                if lower.size == 1:
                    lower = lower.item()
                elif (lower.max()-lower.min())/lower.mean() &lt; 1e-6:
                    lower = lower.mean().item()
                else:
                    lower = lower.tolist()
            if upper is not None:
                if upper.size == 1:
                    upper = upper.item()
                elif (upper.max()-upper.min())/upper.mean() &lt; 1e-6:
                    upper = upper.mean().item()
                else:
                    upper = upper.tolist()

            if pegged:
                return &#34;pegged&#34;
            elif not train:
                return &#34;fixed&#34;
            if lower is None and upper is None:
                return &#34;(-∞, ∞)&#34;
            elif lower is None:
                return &#34;(-∞, %s]&#34; % upper
            elif upper is None:
                return &#34;[%s, ∞)&#34; % lower
            return &#34;[%s, %s]&#34; % (lower, upper)

        if file is None:
            try:
                get_ipython  # fails if we&#39;re not in a notebook
                table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;&lt;th&gt;Range&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
                for p in self._params:
                    table += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (p.name, param_range(p.lower, p.upper, p.train, p.pegged), p.numpy())
                table += &#39;&lt;/table&gt;&#39;
                display(HTML(table))
                return
            except Exception as e:
                pass

        vals = [[&#34;Name&#34;, &#34;Range&#34;, &#34;Value&#34;]]
        for p in self._params:
            vals.append([p.name, param_range(p.lower, p.upper, p.train, p.pegged), p.numpy().tolist()])

        nameWidth = max([len(val[0]) for val in vals])
        rangeWidth = max([len(val[1]) for val in vals])
        for val in vals:
            #print(&#34;%-*s  %-*s  %s&#34; % (nameWidth, val[0], rangeWidth, val[1], val[2]), file=file)
            print(&#34;%-*s  %s&#34; % (nameWidth, val[0], val[2]), file=file)

    def _cholesky(self, K, add_jitter=False):
        if add_jitter:
            K += (self.jitter * K.diagonal().mean()).repeat(K.shape[0]).diagflat()
        try:
            return torch.linalg.cholesky(K)
        except RuntimeError as e:
            print(&#34;ERROR:&#34;, e.args[0], file=sys.__stdout__)
            if K.isnan().any():
                print(&#34;ERROR: kernel matrix has NaNs!&#34;, file=sys.__stdout__)
            if K.isinf().any():
                print(&#34;ERROR: kernel matrix has infinities!&#34;, file=sys.__stdout__)
            self.print_parameters()
            plot_gram(K)
            raise CholeskyException(e.args[0], K, self)

    def log_marginal_likelihood(self):
        &#34;&#34;&#34;
        Return the log marginal likelihood given by

        $$ \\log p(y) $$

        Returns:
            torch.tensor: Log marginal likelihood.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def log_prior(self):
        &#34;&#34;&#34;
        Return the log prior given by

        $$ \\log p(\\theta) $$

        Returns:
            torch.tensor: Log prior.
        &#34;&#34;&#34;
        return sum([p.log_prior() for p in self._params])

    def loss(self):
        &#34;&#34;&#34;
        Model loss for training.

        Returns:
            torch.tensor: Loss.
        &#34;&#34;&#34;
        self.zero_grad()
        loss = -self.log_marginal_likelihood() - self.log_prior()
        loss.backward()
        return loss

    def K(self, X1, X2=None):
        &#34;&#34;&#34;
        Evaluate kernel at `X1` and `X2` and return the NumPy representation.

        Args:
            X1 (torch.tensor): Input of shape (data_points0,input_dims).
            X2 (torch.tensor): Input of shape (data_points1,input_dims).

        Returns:
            numpy.ndarray: Kernel matrix of shape (data_points0,data_points1).
        &#34;&#34;&#34;
        with torch.no_grad():
            return self.kernel(X1, X2).cpu().numpy()

    def sample(self, Z, n=None, predict_y=True, prior=False):
        &#34;&#34;&#34;
        Sample from model.

        Args:
            Z (torch.tensor): Input of shape (data_points,input_dims).
            n (int): Number of samples.
            predict_y (boolean): Predict the data values \\(y\\) instead of the function values \\(f\\).
            prior (boolean): Sample from prior instead of posterior.

        Returns:
            torch.tensor: Samples of shape (data_points,samples) or (data_points,) if `n` is not given.
        &#34;&#34;&#34;
        with torch.no_grad():
            S = n
            if n is None:
                S = 1

            # TODO: predict_y and non-Gaussian likelihoods
            if prior:
                mu, var = self.mean(Z), self.kernel(Z)
            else:
                mu, var = self.predict(Z, full=True, tensor=True, predict_y=predict_y)  # MxD, MxMxD
            eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
            var += self.jitter * var.diagonal().mean() * eye  # MxM

            u = torch.normal(
                    torch.zeros(Z.shape[0], S, device=config.device, dtype=config.dtype),
                    torch.tensor(1.0, device=config.device, dtype=config.dtype))  # MxS
            L = torch.linalg.cholesky(var)  # MxM
            samples = mu + L.mm(u)  # MxS

            if n is None:
                samples = samples.squeeze()
            return samples.cpu().numpy()

class Exact(Model):
    &#34;&#34;&#34;
    Regular Gaussian process regression with a Gaussian likelihood which allows for exact inference.

    $$ y \\sim \\mathcal{N}(0, K + \\sigma^2I) $$

    Args:
        kernel (mpgptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        variance (float,torch.tensor): Gaussian likelihood initial variance. Passing a float will train a single variance for all channels. Passing a tensor of shape (channels,) will assign and train different variances per multi-output channel.
        data_variance (torch.tensor): Assign different and fixed variances per data point. These are added to the kernel&#39;s diagonal while still training an additional Gaussian variance.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, variance=1.0, data_variance=None, jitter=1e-8, mean=None, name=&#34;Exact&#34;):
        if data_variance is not None:
            data_variance = Parameter.to_tensor(data_variance)
            if data_variance.ndim != 1 or X.ndim == 2 and data_variance.shape[0] != X.shape[0]:
                raise ValueError(&#34;data variance must have shape (data_points,)&#34;)
            data_variance = data_variance.diagflat()
        self.data_variance = data_variance

        variance = Parameter.to_tensor(variance)
        channels = 1
        if kernel.output_dims is not None:
            channels = kernel.output_dims
        if 1 &lt; variance.ndim or variance.ndim == 1 and variance.shape[0] != channels:
            raise ValueError(&#34;variance must be float or have shape (channels,)&#34;)

        super().__init__(kernel, X, y, GaussianLikelihood(torch.sqrt(variance)), jitter, mean, name)

        self.eye = torch.eye(self.X.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)

    def log_marginal_likelihood(self):
        Kff = self.kernel.K(self.X)
        Kff += self._index_channel(self.likelihood.scale().square(), self.X) * self.eye  # NxN
        if self.data_variance is not None:
            Kff += self.data_variance
        L = self._cholesky(Kff, add_jitter=True)  # NxN

        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken inside the log: L is the square root
        p -= 0.5*y.T.mm(torch.cholesky_solve(y,L)).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff = self.kernel.K(self.X)
            Kff += self._index_channel(self.likelihood.scale().square(), self.X) * self.eye  # NxN
            if self.data_variance is not None:
                Kff += self.data_variance
            Kfs = self.kernel.K(self.X,Xs)  # NxM

            Lff = self._cholesky(Kff, add_jitter=True)  # NxN
            v = torch.linalg.solve_triangular(Lff,Kfs,upper=False)  # NxM

            mu = Kfs.T.mm(torch.cholesky_solve(y,Lff))  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel.K(Xs)  # MxM
                var = Kss - v.T.mm(v)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._index_channel(self.likelihood.scale().square(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - v.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.scale().square(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class Snelson(Model):
    &#34;&#34;&#34;
    A sparse Gaussian process regression based on Snelson and Ghahramani [1] with a Gaussian likelihood and inducing points.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        Z (int,torch.tensor): Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.
        Z_init (str): Method for initialization of inducing points, can be `grid`, `random`, or `density`.
        variance (float,torch.tensor): Gaussian likelihood initial variance. Passing a float will train a single variance for all channels. Passing a tensor of shape (channels,) will assign and train different variances per multi-output channel.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] E. Snelson, Z. Ghahramani, &#34;Sparse Gaussian Processes using Pseudo-inputs&#34;, 2005
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, Z=10, Z_init=&#39;grid&#39;, variance=1.0, jitter=1e-8, mean=None,
                 name=&#34;Snelson&#34;):
        variance = Parameter.to_tensor(variance).squeeze()
        if 1 &lt; variance.ndim or variance.ndim == 1 and variance.shape[0] != kernel.output_dims:
            raise ValueError(&#34;variance must be float or have shape (channels,)&#34;)

        super().__init__(kernel, X, y, GaussianLikelihood(torch.sqrt(variance)), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, method=Z_init, output_dims=kernel.output_dims)
        Z = self._check_input(Z)
        
        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)
        if kernel.output_dims is not None:
            self.Z.num_parameters -= self.Z().shape[0]

    def log_marginal_likelihood(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel.K(self.Z(),self.X)  # MxN
        Kuu = self.kernel.K(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Luu = Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.scale().square(), self.X)  # N;  diag(Kff-Qff) + sigma^2.I
        G = torch.diagflat(1.0/g)  # N
        L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= 0.5*g.log().sum()
        p -= 0.5*y.T.mm(G).mm(y).squeeze()
        p += 0.5*c.T.mm(c).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff_diag = self.kernel.K_diag(self.X)  # N
            Kuf = self.kernel.K(self.Z(),self.X)  # MxN
            Kuu = self.kernel.K(self.Z())  # MxM
            Kus = self.kernel.K(self.Z(),Xs)  # MxS

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.scale().square(), self.X)
            G = torch.diagflat(1.0/g)  # N
            L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxM
            b = torch.linalg.solve_triangular(L,a,upper=False)
            c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(w) + b.T.mm(u)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._select_channel(self.likelihood.scale().square(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.scale().square(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class OpperArchambeau(Model):
    &#34;&#34;&#34;
    A Gaussian process regression based on Opper and Archambeau [1] with a non-Gaussian likelihood.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] M. Opper, C. Archambeau, &#34;The Variational Gaussian Approximation Revisited&#34;, 2009
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0),
                 jitter=1e-8, mean=None, name=&#34;OpperArchambeau&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        n = self.X.shape[0]
        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.q_nu = Parameter(torch.zeros(n,1), name=&#34;q_nu&#34;)
        self.q_lambda = Parameter(torch.ones(n,1), name=&#34;q_lambda&#34;, lower=config.positive_minimum)
        self.likelihood = likelihood

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        q_nu = self.q_nu()
        q_lambda = self.q_lambda()

        Kff = self.kernel(self.X)  # NxN
        L = self._cholesky(q_lambda*q_lambda.T*Kff + self.eye)
        invL = torch.linalg.solve_triangular(L,self.eye,upper=False)  # NxN

        qf_mu = Kff.mm(q_nu)
        qf_var_diag = 1.0/q_lambda.square() - (invL.T.mm(invL)/q_lambda/q_lambda.T).diagonal().reshape(-1,1)

        kl = -q_nu.shape[0]
        kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
        kl += L.diagonal().square().log().sum()  # determinant TODO: is this correct?
        #kl += invL.diagonal().square().sum()  # trace
        kl += invL.square().sum()  # trace

        if self.mean is not None:
            qf_mu = qf_mu - self.mean(self.X).reshape(-1,1)  # Sx1
        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)

        #eye = torch.eye(q_lambda.shape[0], device=config.device, dtype=config.dtype)
        #qf_var = (1.0/q_lambda.square())*eye - invL.T.mm(invL)/q_lambda/q_lambda.T
        #kl = -q_nu.shape[0]
        #kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
        #kl -= qf_var.det().log()  # determinant
        #kl += invL.diagonal().square().sum()  # trace

        #kl = -q_nu.shape[0]
        #kl += q_nu.T.mm(q_nu).squeeze()  # Mahalanobis
        #kl -= qf_var.det().log()  # determinant
        #kl += qf_var_diag.sum()  # trace
        return var_exp - 0.5*kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            Kff = self.kernel(self.X)
            Kfs = self.kernel(self.X,Xs)  # NxS

            L = self._cholesky(Kff + (1.0/self.q_lambda().square()).diagflat())  # NxN
            a = torch.linalg.solve_triangular(L,Kfs,upper=False)  # NxS;  Kuu^(-1/2).Kus

            mu = Kfs.T.mm(self.q_nu())  # Sx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if full:
                Kss = self.kernel(Xs)  # SxS
                var = Kss - a.T.mm(a)  # SxS
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1)  # M
                var = var.reshape(-1,1)

            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class Titsias(Model):
    &#34;&#34;&#34;
    A sparse Gaussian process regression based on Titsias [1] with a Gaussian likelihood.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        Z (int,torch.tensor): Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.
        Z_init (str): Method for initialization of inducing points, can be `grid`, `random`, or `density`.
        variance (float): Gaussian likelihood initial variance.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] Titsias, &#34;Variational learning of induced variables in sparse Gaussian processes&#34;, 2009
    &#34;&#34;&#34;
    # See: http://krasserm.github.io/2020/12/12/gaussian-processes-sparse/
    def __init__(self, kernel, X, y, Z, Z_init=&#39;grid&#39;, variance=1.0, jitter=1e-8,
                 mean=None, name=&#34;Titsias&#34;):
        # TODO: variance per channel
        variance = Parameter.to_tensor(variance)
        super().__init__(kernel, X, y, GaussianLikelihood(torch.sqrt(variance)), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, method=Z_init, output_dims=kernel.output_dims)
        Z = self._check_input(Z)

        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)
        if kernel.output_dims is not None:
            self.Z.num_parameters -= self.Z().shape[0]

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel(self.Z(),self.X)  # MxN
        Kuu = self.kernel(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        Q = v.mm(v.T)  # MxM;  Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)
        L = self._cholesky(Q/self.likelihood.scale().square() + self.eye)  # MxM;  (Q/sigma^2 + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.scale().square()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

        # p = log N(0, Kfu.Kuu^(-1).Kuf + I/sigma^2) - 1/(2.sigma^2).Trace(Kff - Kfu.Kuu^(-1).Kuf)
        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= self.X.shape[0]*self.likelihood.scale().log()
        p -= 0.5*y.T.mm(y).squeeze()/self.likelihood.scale().square()
        p += 0.5*c.T.mm(c).squeeze()
        p -= 0.5*(Kff_diag.sum() - Q.trace())/self.likelihood.scale().square() # trace
        return p

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kus = self.kernel(self.Z(),Xs)  # MxS
            Kuf = self.kernel(self.Z(),self.X)  # MxN
            Kuu = self.kernel(self.Z())  # MxM

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            L = self._cholesky(v.mm(v.T)/self.likelihood.scale().square() + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)/sigma^2 + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # MxS;  Kuu^(-1/2).Kus
            b = torch.linalg.solve_triangular(L,a,upper=False)  # MxS;  L^(-1).Kuu^(-1/2).Kus
            c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.scale().square()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

            # mu = sigma^(-2).Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kuf.y
            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            # var = Kss - Qsf.(Qff + sigma^2 I)^(-1).Qfs
            # below is the equivalent but more stable version by using the matrix inversion lemma
            # var = Kss - Ksu.Kuu^(-1).Kus + Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kus
            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(a) + b.T.mm(b)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self.likelihood.scale().square() * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self.likelihood.scale().square()
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class SparseHensman(Model):
    &#34;&#34;&#34;
    A sparse Gaussian process regression based on Hensman et al. [1] with a non-Gaussian likelihood.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        Z (int,torch.tensor): Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.
        Z_init (str): Method for initialization of inducing points, can be `grid`, `random`, or `density`.
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] J. Hensman, et al., &#34;Scalable Variational Gaussian Process Classification&#34;, 2015
    &#34;&#34;&#34;
    # This version replaces mu_q by L.mu_q and sigma_q by L.sigma_q.L^T, where LL^T = Kuu
    # So that p(u) ~ N(0,1) and q(u) ~ N(L.mu_q, L.sigma_q.L^T)
    def __init__(self, kernel, X, y, Z=None, Z_init=&#39;grid&#39;,
                 likelihood=GaussianLikelihood(1.0), jitter=1e-8, mean=None,
                 name=&#34;SparseHensman&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        n = self.X.shape[0]
        self.is_sparse = Z is not None
        if self.is_sparse:
            Z = init_inducing_points(Z, self.X, method=Z_init, output_dims=kernel.output_dims)
            Z = self._check_input(Z)
            n = Z.shape[0]

        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.q_mu = Parameter(torch.zeros(n,1), name=&#34;q_mu&#34;)
        self.q_sqrt = Parameter(torch.eye(n), name=&#34;q_sqrt&#34;)
        self.q_sqrt.num_parameters = int((n*n+n)/2)
        if self.is_sparse:
            self.Z = Parameter(Z, name=&#34;induction_points&#34;)
            if kernel.output_dims is not None:
                self.Z.num_parameters -= self.Z().shape[0]
        else:
            self.Z = Parameter(self.X, train=False)  # don&#39;t use inducing points

    def kl_gaussian(self, q_mu, q_sqrt):
        S_diag = q_sqrt.diagonal().square() # NxN
        kl = -q_mu.shape[0]
        kl += q_mu.T.mm(q_mu).squeeze()  # Mahalanobis
        kl -= S_diag.log().sum()  # determinant of q_var
        kl += S_diag.sum()  # same as Trace(p_var^(-1).q_var)
        return 0.5*kl

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        if self.is_sparse:
            qf_mu, qf_var_diag = self._predict(self.X, full=False)
        else:
            Kff = self.kernel(self.X)
            Lff = self._cholesky(Kff, add_jitter=True)  # NxN

            qf_mu = Lff.mm(self.q_mu())
            if self.mean is not None:
                qf_mu -= self.mean(self.X).reshape(-1,1)  # Sx1

            qf_sqrt = Lff.mm(self.q_sqrt().tril())
            qf_var_diag = qf_sqrt.mm(qf_sqrt.T).diagonal().reshape(-1,1)

        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)
        kl = self.kl_gaussian(self.q_mu(), self.q_sqrt())
        return var_exp - kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def _predict(self, Xs, full=False):
        Kuu = self.kernel(self.Z())
        Kus = self.kernel(self.Z(),Xs)  # NxS

        Luu = self._cholesky(Kuu, add_jitter=True)  # NxN
        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxS;  Kuu^(-1/2).Kus
        b = self.q_sqrt().tril().T.mm(torch.linalg.solve_triangular(Luu,Kus,upper=False))

        mu = Kus.T.mm(torch.linalg.solve_triangular(Luu.T,self.q_mu(),upper=True))  # Sx1
        if full:
            Kss = self.kernel(Xs)  # SxS
            var = Kss - a.T.mm(a) + b.T.mm(b)  # SxS
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            var = var.reshape(-1,1)
        return mu, var

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            mu, var = self._predict(Xs, full=full)
            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()

class Hensman(SparseHensman):
    &#34;&#34;&#34;
    A Gaussian process regression based on Hensman et al. [1] with a non-Gaussian likelihood. This is equivalent to the `SparseHensman` model if we set the inducing points equal to the data points and by turning off training the inducing points.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] J. Hensman, et al., &#34;Scalable Variational Gaussian Process Classification&#34;, 2015
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0), jitter=1e-8,
                 mean=None, name=&#34;Hensman&#34;):
        super().__init__(kernel, X, y, None, likelihood, jitter, mean, name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mogptk.gpr.model.init_inducing_points"><code class="name flex">
<span>def <span class="ident">init_inducing_points</span></span>(<span>Z, X, method='grid', output_dims=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize locations for inducing points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>int,list</code></dt>
<dd>Number of inducing points. A list of ints of shape (output_dims,) will initialize the specified number of inducing points per output dimension.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Method for initialization, can be <code>grid</code>, <code>random</code>, or <code>density</code>.</dd>
<dt><strong><code>output_dims</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of output dimensions. If not None, the first input dimension of the input data must contain the channel IDs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.tensor</code></dt>
<dd>Inducing point locations of shape (data_points,input_dims). In case of multiple output dimensions, the first input dimension will be the channel ID.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L36-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def init_inducing_points(Z, X, method=&#39;grid&#39;, output_dims=None):
    &#34;&#34;&#34;
    Initialize locations for inducing points.

    Args:
        Z (int,list): Number of inducing points. A list of ints of shape (output_dims,) will initialize the specified number of inducing points per output dimension.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        method (str): Method for initialization, can be `grid`, `random`, or `density`.
        output_dims (int): Number of output dimensions. If not None, the first input dimension of the input data must contain the channel IDs.

    Returns:
        torch.tensor: Inducing point locations of shape (data_points,input_dims). In case of multiple output dimensions, the first input dimension will be the channel ID.
    &#34;&#34;&#34;
    _init = _init_grid
    if method == &#39;random&#39;:
        _init = _init_random
    elif method == &#39;density&#39;:
        _init = _init_density

    if output_dims is not None:
        if isinstance(Z, int) or all(isinstance(z, int) for z in Z) and len(Z) == output_dims:
            if isinstance(Z, int):
                Z = [Z] * output_dims
            M = Z
            Z = torch.zeros((sum(M),X.shape[1]))
            for j in range(len(M)):
                m0 = sum(M[:j])
                m = M[j]
                Z[m0:m0+m,0] = j
                Z[m0:m0+m,1:] = _init(m, X[X[:,0] == j,1:])
    elif isinstance(Z, int):
        M = Z
        Z = _init(M, X)
    return Z</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mogptk.gpr.model.CholeskyException"><code class="flex name class">
<span>class <span class="ident">CholeskyException</span></span>
<span>(</span><span>message, K, model)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L71-L78" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CholeskyException(Exception):
    def __init__(self, message, K, model):
        self.message = message
        self.K = K
        self.model = model

    def __str__(self):
        return self.message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Exact"><code class="flex name class">
<span>class <span class="ident">Exact</span></span>
<span>(</span><span>kernel, X, y, variance=1.0, data_variance=None, jitter=1e-08, mean=None, name='Exact')</span>
</code></dt>
<dd>
<div class="desc"><p>Regular Gaussian process regression with a Gaussian likelihood which allows for exact inference.</p>
<p><span><span class="MathJax_Preview"> y \sim \mathcal{N}(0, K + \sigma^2I) </span><script type="math/tex; mode=display"> y \sim \mathcal{N}(0, K + \sigma^2I) </script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code>mpgptk.gpr.kernel.Kernel</code></dt>
<dd>Kernel.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Output data of shape (data_points,).</dd>
<dt><strong><code>variance</code></strong> :&ensp;<code>float,torch.tensor</code></dt>
<dd>Gaussian likelihood initial variance. Passing a float will train a single variance for all channels. Passing a tensor of shape (channels,) will assign and train different variances per multi-output channel.</dd>
<dt><strong><code>data_variance</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Assign different and fixed variances per data point. These are added to the kernel's diagonal while still training an additional Gaussian variance.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative jitter of the diagonal's mean added to the kernel's diagonal before calculating the Cholesky.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L367-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Exact(Model):
    &#34;&#34;&#34;
    Regular Gaussian process regression with a Gaussian likelihood which allows for exact inference.

    $$ y \\sim \\mathcal{N}(0, K + \\sigma^2I) $$

    Args:
        kernel (mpgptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        variance (float,torch.tensor): Gaussian likelihood initial variance. Passing a float will train a single variance for all channels. Passing a tensor of shape (channels,) will assign and train different variances per multi-output channel.
        data_variance (torch.tensor): Assign different and fixed variances per data point. These are added to the kernel&#39;s diagonal while still training an additional Gaussian variance.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, variance=1.0, data_variance=None, jitter=1e-8, mean=None, name=&#34;Exact&#34;):
        if data_variance is not None:
            data_variance = Parameter.to_tensor(data_variance)
            if data_variance.ndim != 1 or X.ndim == 2 and data_variance.shape[0] != X.shape[0]:
                raise ValueError(&#34;data variance must have shape (data_points,)&#34;)
            data_variance = data_variance.diagflat()
        self.data_variance = data_variance

        variance = Parameter.to_tensor(variance)
        channels = 1
        if kernel.output_dims is not None:
            channels = kernel.output_dims
        if 1 &lt; variance.ndim or variance.ndim == 1 and variance.shape[0] != channels:
            raise ValueError(&#34;variance must be float or have shape (channels,)&#34;)

        super().__init__(kernel, X, y, GaussianLikelihood(torch.sqrt(variance)), jitter, mean, name)

        self.eye = torch.eye(self.X.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)

    def log_marginal_likelihood(self):
        Kff = self.kernel.K(self.X)
        Kff += self._index_channel(self.likelihood.scale().square(), self.X) * self.eye  # NxN
        if self.data_variance is not None:
            Kff += self.data_variance
        L = self._cholesky(Kff, add_jitter=True)  # NxN

        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken inside the log: L is the square root
        p -= 0.5*y.T.mm(torch.cholesky_solve(y,L)).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff = self.kernel.K(self.X)
            Kff += self._index_channel(self.likelihood.scale().square(), self.X) * self.eye  # NxN
            if self.data_variance is not None:
                Kff += self.data_variance
            Kfs = self.kernel.K(self.X,Xs)  # NxM

            Lff = self._cholesky(Kff, add_jitter=True)  # NxN
            v = torch.linalg.solve_triangular(Lff,Kfs,upper=False)  # NxM

            mu = Kfs.T.mm(torch.cholesky_solve(y,Lff))  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel.K(Xs)  # MxM
                var = Kss - v.T.mm(v)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._index_channel(self.likelihood.scale().square(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - v.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.scale().square(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Exact.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L420-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff = self.kernel.K(self.X)
        Kff += self._index_channel(self.likelihood.scale().square(), self.X) * self.eye  # NxN
        if self.data_variance is not None:
            Kff += self.data_variance
        Kfs = self.kernel.K(self.X,Xs)  # NxM

        Lff = self._cholesky(Kff, add_jitter=True)  # NxN
        v = torch.linalg.solve_triangular(Lff,Kfs,upper=False)  # NxM

        mu = Kfs.T.mm(torch.cholesky_solve(y,Lff))  # Mx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Mx1

        if full:
            Kss = self.kernel.K(Xs)  # MxM
            var = Kss - v.T.mm(v)  # MxM
            if predict_y:
                eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                var += self._index_channel(self.likelihood.scale().square(), Xs) * eye
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - v.T.square().sum(dim=1)  # M
            if predict_y:
                var += self._index_channel(self.likelihood.scale().square(), Xs)
            var = var.reshape(-1,1)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Hensman"><code class="flex name class">
<span>class <span class="ident">Hensman</span></span>
<span>(</span><span>kernel, X, y, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name='Hensman')</span>
</code></dt>
<dd>
<div class="desc"><p>A Gaussian process regression based on Hensman et al. [1] with a non-Gaussian likelihood. This is equivalent to the <code><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></code> model if we set the inducing points equal to the data points and by turning off training the inducing points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code><a title="mogptk.gpr.kernel.Kernel" href="kernel.html#mogptk.gpr.kernel.Kernel">Kernel</a></code></dt>
<dd>Kernel.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Output data of shape (data_points,).</dd>
<dt><strong><code>likelihood</code></strong> :&ensp;<code><a title="mogptk.gpr.likelihood.Likelihood" href="likelihood.html#mogptk.gpr.likelihood.Likelihood">Likelihood</a></code></dt>
<dd>Likelihood.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative jitter of the diagonal's mean added to the kernel's diagonal before calculating the Cholesky.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
</dl>
<p>[1] J. Hensman, et al., "Scalable Variational Gaussian Process Classification", 2015</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L881-L898" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Hensman(SparseHensman):
    &#34;&#34;&#34;
    A Gaussian process regression based on Hensman et al. [1] with a non-Gaussian likelihood. This is equivalent to the `SparseHensman` model if we set the inducing points equal to the data points and by turning off training the inducing points.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] J. Hensman, et al., &#34;Scalable Variational Gaussian Process Classification&#34;, 2015
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0), jitter=1e-8,
                 mean=None, name=&#34;Hensman&#34;):
        super().__init__(kernel, X, y, None, likelihood, jitter, mean, name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></li>
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.gpr.model.SparseHensman.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>kernel, X, y, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base model class.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code><a title="mogptk.gpr.kernel.Kernel" href="kernel.html#mogptk.gpr.kernel.Kernel">Kernel</a></code></dt>
<dd>Kernel.</dd>
<dt><strong><code>likelihood</code></strong> :&ensp;<code><a title="mogptk.gpr.likelihood.Likelihood" href="likelihood.html#mogptk.gpr.likelihood.Likelihood">Likelihood</a></code></dt>
<dd>Likelihood.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L80-L365" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Model:
    &#34;&#34;&#34;
    Base model class.

    Attributes:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        mean (mogptk.gpr.mean.Mean): Mean.
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0), jitter=1e-8, mean=None, name=None):
        if not issubclass(type(kernel), Kernel):
            raise ValueError(&#34;kernel must derive from mogptk.gpr.Kernel&#34;)
        X, y = self._check_input(X, y)
        if mean is not None:
            if not issubclass(type(mean), Mean):
                raise ValueError(&#34;mean must derive from mogptk.gpr.Mean&#34;)
            mu = mean(X).reshape(-1,1)
            if mu.shape != y.shape:
                raise ValueError(&#34;mean and y data must match shapes: %s != %s&#34; % (mu.shape, y.shape))

        if issubclass(type(likelihood), MultiOutputLikelihood) and likelihood.output_dims != kernel.output_dims:
            raise ValueError(&#34;kernel and likelihood must have matching output dimensions&#34;)
        likelihood.validate_y(y, X=X)

        # limit to number of significant digits
        if config.dtype == torch.float32:
            jitter = max(jitter, 1e-6)
        elif config.dtype == torch.float64:
            jitter = max(jitter, 1e-15)

        self._params = []
        self.kernel = kernel
        self.X = X
        self.y = y
        self.likelihood = likelihood
        self.jitter = jitter
        self.mean = mean
        self.name = name
        self.input_dims = X.shape[1]

    def __setattr__(self, name, val):
        if hasattr(self, name) and isinstance(getattr(self, name), Parameter):
            raise AttributeError(&#34;parameter is read-only, use Parameter.assign()&#34;)
        elif isinstance(val, (Parameter, Kernel, Mean, Likelihood)):
            self._register_parameters(val)
        super().__setattr__(name, val)        

    def _check_input(self, X, y=None):
        if not isinstance(X, torch.Tensor):
            X = torch.tensor(X, device=config.device, dtype=config.dtype)
        else:
            X = X.to(config.device, config.dtype)
        if X.ndim == 0:
            X = X.reshape(1,1)
        elif X.ndim == 1:
            X = X.reshape(-1,1)
        elif X.ndim != 2:
            raise ValueError(&#34;X must have dimensions (data_points,input_dims) with input_dims optional&#34;)
        if X.shape[0] == 0 or X.shape[1] == 0:
            raise ValueError(&#34;X must not be empty&#34;)

        if y is not None:
            if not isinstance(y, torch.Tensor):
                y = torch.tensor(y, device=config.device, dtype=config.dtype)
            else:
                y = y.to(config.device, config.dtype)
            if y.ndim == 0:
                y = y.reshape(1,1)
            elif y.ndim == 1:
                y = y.reshape(-1,1)
            elif y.ndim != 2 or y.shape[1] != 1:
                raise ValueError(&#34;y must have one dimension (data_points,)&#34;)
            if X.shape[0] != y.shape[0]:
                raise ValueError(&#34;number of data points for X and y must match&#34;)
            return X, y
        else:
            # X is for prediction
            if X.shape[1] != self.input_dims:
                raise ValueError(&#34;X must have %s input dimensions&#34; % self.input_dims)
            return X

    def _index_channel(self, value, X):
        if self.kernel.output_dims is not None and 0 &lt; value.ndim and value.shape[0] == self.kernel.output_dims:
            return torch.index_select(value, dim=0, index=X[:,0].long())
        return value

    def _register_parameters(self, obj, name=None):
        if isinstance(obj, Parameter):
            if obj.name is not None:
                if name is None:
                    name = obj.name
                else:
                    name += &#34;.&#34; + obj.name
            elif name is None:
                name = &#34;&#34;
            obj.name = name
            self._params.append(obj)
        elif isinstance(obj, list):
            for i, v in enumerate(obj):
                self._register_parameters(v, (name if name is not None else &#34;&#34;)+&#34;[&#34;+str(i)+&#34;]&#34;)
        elif issubclass(type(obj), (Kernel, Mean, Likelihood)):
            for v in obj.__dict__.values():
                self._register_parameters(v, (name+&#34;.&#34; if name is not None else &#34;&#34;)+obj.name)

    def zero_grad(self):
        for p in self._params:
            p = p.unconstrained
            if p.grad is not None:
                if p.grad.grad_fn is not None:
                    p.grad.detach_()
                else:
                    p.grad.requires_grad_(False)
                p.grad.zero_()

    def parameters(self):
        &#34;&#34;&#34;
        Yield trainable parameters of model.

        Returns:
            Parameter generator
        &#34;&#34;&#34;
        for p in self._params:
            if p.train:
                yield p.unconstrained

    def get_parameters(self):
        &#34;&#34;&#34;
        Return all parameters of model.

        Returns:
            list: List of Parameters.
        &#34;&#34;&#34;
        return self._params
    
    def print_parameters(self, file=None):
        &#34;&#34;&#34;
        Print parameters and their values.
        &#34;&#34;&#34;
        def param_range(lower, upper, train=True, pegged=False):
            if lower is not None:
                if lower.size == 1:
                    lower = lower.item()
                elif (lower.max()-lower.min())/lower.mean() &lt; 1e-6:
                    lower = lower.mean().item()
                else:
                    lower = lower.tolist()
            if upper is not None:
                if upper.size == 1:
                    upper = upper.item()
                elif (upper.max()-upper.min())/upper.mean() &lt; 1e-6:
                    upper = upper.mean().item()
                else:
                    upper = upper.tolist()

            if pegged:
                return &#34;pegged&#34;
            elif not train:
                return &#34;fixed&#34;
            if lower is None and upper is None:
                return &#34;(-∞, ∞)&#34;
            elif lower is None:
                return &#34;(-∞, %s]&#34; % upper
            elif upper is None:
                return &#34;[%s, ∞)&#34; % lower
            return &#34;[%s, %s]&#34; % (lower, upper)

        if file is None:
            try:
                get_ipython  # fails if we&#39;re not in a notebook
                table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;&lt;th&gt;Range&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
                for p in self._params:
                    table += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (p.name, param_range(p.lower, p.upper, p.train, p.pegged), p.numpy())
                table += &#39;&lt;/table&gt;&#39;
                display(HTML(table))
                return
            except Exception as e:
                pass

        vals = [[&#34;Name&#34;, &#34;Range&#34;, &#34;Value&#34;]]
        for p in self._params:
            vals.append([p.name, param_range(p.lower, p.upper, p.train, p.pegged), p.numpy().tolist()])

        nameWidth = max([len(val[0]) for val in vals])
        rangeWidth = max([len(val[1]) for val in vals])
        for val in vals:
            #print(&#34;%-*s  %-*s  %s&#34; % (nameWidth, val[0], rangeWidth, val[1], val[2]), file=file)
            print(&#34;%-*s  %s&#34; % (nameWidth, val[0], val[2]), file=file)

    def _cholesky(self, K, add_jitter=False):
        if add_jitter:
            K += (self.jitter * K.diagonal().mean()).repeat(K.shape[0]).diagflat()
        try:
            return torch.linalg.cholesky(K)
        except RuntimeError as e:
            print(&#34;ERROR:&#34;, e.args[0], file=sys.__stdout__)
            if K.isnan().any():
                print(&#34;ERROR: kernel matrix has NaNs!&#34;, file=sys.__stdout__)
            if K.isinf().any():
                print(&#34;ERROR: kernel matrix has infinities!&#34;, file=sys.__stdout__)
            self.print_parameters()
            plot_gram(K)
            raise CholeskyException(e.args[0], K, self)

    def log_marginal_likelihood(self):
        &#34;&#34;&#34;
        Return the log marginal likelihood given by

        $$ \\log p(y) $$

        Returns:
            torch.tensor: Log marginal likelihood.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def log_prior(self):
        &#34;&#34;&#34;
        Return the log prior given by

        $$ \\log p(\\theta) $$

        Returns:
            torch.tensor: Log prior.
        &#34;&#34;&#34;
        return sum([p.log_prior() for p in self._params])

    def loss(self):
        &#34;&#34;&#34;
        Model loss for training.

        Returns:
            torch.tensor: Loss.
        &#34;&#34;&#34;
        self.zero_grad()
        loss = -self.log_marginal_likelihood() - self.log_prior()
        loss.backward()
        return loss

    def K(self, X1, X2=None):
        &#34;&#34;&#34;
        Evaluate kernel at `X1` and `X2` and return the NumPy representation.

        Args:
            X1 (torch.tensor): Input of shape (data_points0,input_dims).
            X2 (torch.tensor): Input of shape (data_points1,input_dims).

        Returns:
            numpy.ndarray: Kernel matrix of shape (data_points0,data_points1).
        &#34;&#34;&#34;
        with torch.no_grad():
            return self.kernel(X1, X2).cpu().numpy()

    def sample(self, Z, n=None, predict_y=True, prior=False):
        &#34;&#34;&#34;
        Sample from model.

        Args:
            Z (torch.tensor): Input of shape (data_points,input_dims).
            n (int): Number of samples.
            predict_y (boolean): Predict the data values \\(y\\) instead of the function values \\(f\\).
            prior (boolean): Sample from prior instead of posterior.

        Returns:
            torch.tensor: Samples of shape (data_points,samples) or (data_points,) if `n` is not given.
        &#34;&#34;&#34;
        with torch.no_grad():
            S = n
            if n is None:
                S = 1

            # TODO: predict_y and non-Gaussian likelihoods
            if prior:
                mu, var = self.mean(Z), self.kernel(Z)
            else:
                mu, var = self.predict(Z, full=True, tensor=True, predict_y=predict_y)  # MxD, MxMxD
            eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
            var += self.jitter * var.diagonal().mean() * eye  # MxM

            u = torch.normal(
                    torch.zeros(Z.shape[0], S, device=config.device, dtype=config.dtype),
                    torch.tensor(1.0, device=config.device, dtype=config.dtype))  # MxS
            L = torch.linalg.cholesky(var)  # MxM
            samples = mu + L.mm(u)  # MxS

            if n is None:
                samples = samples.squeeze()
            return samples.cpu().numpy()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Exact" href="#mogptk.gpr.model.Exact">Exact</a></li>
<li><a title="mogptk.gpr.model.OpperArchambeau" href="#mogptk.gpr.model.OpperArchambeau">OpperArchambeau</a></li>
<li><a title="mogptk.gpr.model.Snelson" href="#mogptk.gpr.model.Snelson">Snelson</a></li>
<li><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></li>
<li><a title="mogptk.gpr.model.Titsias" href="#mogptk.gpr.model.Titsias">Titsias</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Model.K"><code class="name flex">
<span>def <span class="ident">K</span></span>(<span>self, X1, X2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate kernel at <code>X1</code> and <code>X2</code> and return the NumPy representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X1</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input of shape (data_points0,input_dims).</dd>
<dt><strong><code>X2</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input of shape (data_points1,input_dims).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Kernel matrix of shape (data_points0,data_points1).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L317-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def K(self, X1, X2=None):
    &#34;&#34;&#34;
    Evaluate kernel at `X1` and `X2` and return the NumPy representation.

    Args:
        X1 (torch.tensor): Input of shape (data_points0,input_dims).
        X2 (torch.tensor): Input of shape (data_points1,input_dims).

    Returns:
        numpy.ndarray: Kernel matrix of shape (data_points0,data_points1).
    &#34;&#34;&#34;
    with torch.no_grad():
        return self.kernel(X1, X2).cpu().numpy()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.get_parameters"><code class="name flex">
<span>def <span class="ident">get_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all parameters of model.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of Parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L205-L212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_parameters(self):
    &#34;&#34;&#34;
    Return all parameters of model.

    Returns:
        list: List of Parameters.
    &#34;&#34;&#34;
    return self._params</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.log_marginal_likelihood"><code class="name flex">
<span>def <span class="ident">log_marginal_likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the log marginal likelihood given by</p>
<p><span><span class="MathJax_Preview"> \log p(y) </span><script type="math/tex; mode=display"> \log p(y) </script></span></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.tensor</code></dt>
<dd>Log marginal likelihood.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L283-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_marginal_likelihood(self):
    &#34;&#34;&#34;
    Return the log marginal likelihood given by

    $$ \\log p(y) $$

    Returns:
        torch.tensor: Log marginal likelihood.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.log_prior"><code class="name flex">
<span>def <span class="ident">log_prior</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the log prior given by</p>
<p><span><span class="MathJax_Preview"> \log p(\theta) </span><script type="math/tex; mode=display"> \log p(\theta) </script></span></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.tensor</code></dt>
<dd>Log prior.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L294-L303" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log_prior(self):
    &#34;&#34;&#34;
    Return the log prior given by

    $$ \\log p(\\theta) $$

    Returns:
        torch.tensor: Log prior.
    &#34;&#34;&#34;
    return sum([p.log_prior() for p in self._params])</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.loss"><code class="name flex">
<span>def <span class="ident">loss</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Model loss for training.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.tensor</code></dt>
<dd>Loss.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L305-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loss(self):
    &#34;&#34;&#34;
    Model loss for training.

    Returns:
        torch.tensor: Loss.
    &#34;&#34;&#34;
    self.zero_grad()
    loss = -self.log_marginal_likelihood() - self.log_prior()
    loss.backward()
    return loss</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.parameters"><code class="name flex">
<span>def <span class="ident">parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield trainable parameters of model.</p>
<h2 id="returns">Returns</h2>
<p>Parameter generator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L194-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parameters(self):
    &#34;&#34;&#34;
    Yield trainable parameters of model.

    Returns:
        Parameter generator
    &#34;&#34;&#34;
    for p in self._params:
        if p.train:
            yield p.unconstrained</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.print_parameters"><code class="name flex">
<span>def <span class="ident">print_parameters</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Print parameters and their values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L214-L266" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print_parameters(self, file=None):
    &#34;&#34;&#34;
    Print parameters and their values.
    &#34;&#34;&#34;
    def param_range(lower, upper, train=True, pegged=False):
        if lower is not None:
            if lower.size == 1:
                lower = lower.item()
            elif (lower.max()-lower.min())/lower.mean() &lt; 1e-6:
                lower = lower.mean().item()
            else:
                lower = lower.tolist()
        if upper is not None:
            if upper.size == 1:
                upper = upper.item()
            elif (upper.max()-upper.min())/upper.mean() &lt; 1e-6:
                upper = upper.mean().item()
            else:
                upper = upper.tolist()

        if pegged:
            return &#34;pegged&#34;
        elif not train:
            return &#34;fixed&#34;
        if lower is None and upper is None:
            return &#34;(-∞, ∞)&#34;
        elif lower is None:
            return &#34;(-∞, %s]&#34; % upper
        elif upper is None:
            return &#34;[%s, ∞)&#34; % lower
        return &#34;[%s, %s]&#34; % (lower, upper)

    if file is None:
        try:
            get_ipython  # fails if we&#39;re not in a notebook
            table = &#39;&lt;table&gt;&lt;tr&gt;&lt;th style=&#34;text-align:left&#34;&gt;Name&lt;/th&gt;&lt;th&gt;Range&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&#39;
            for p in self._params:
                table += &#39;&lt;tr&gt;&lt;td style=&#34;text-align:left&#34;&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#39; % (p.name, param_range(p.lower, p.upper, p.train, p.pegged), p.numpy())
            table += &#39;&lt;/table&gt;&#39;
            display(HTML(table))
            return
        except Exception as e:
            pass

    vals = [[&#34;Name&#34;, &#34;Range&#34;, &#34;Value&#34;]]
    for p in self._params:
        vals.append([p.name, param_range(p.lower, p.upper, p.train, p.pegged), p.numpy().tolist()])

    nameWidth = max([len(val[0]) for val in vals])
    rangeWidth = max([len(val[1]) for val in vals])
    for val in vals:
        #print(&#34;%-*s  %-*s  %s&#34; % (nameWidth, val[0], rangeWidth, val[1], val[2]), file=file)
        print(&#34;%-*s  %s&#34; % (nameWidth, val[0], val[2]), file=file)</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, Z, n=None, predict_y=True, prior=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Z</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input of shape (data_points,input_dims).</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples.</dd>
<dt><strong><code>predict_y</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Predict the data values <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> instead of the function values <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>.</dd>
<dt><strong><code>prior</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Sample from prior instead of posterior.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>torch.tensor</code></dt>
<dd>Samples of shape (data_points,samples) or (data_points,) if <code>n</code> is not given.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L331-L365" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sample(self, Z, n=None, predict_y=True, prior=False):
    &#34;&#34;&#34;
    Sample from model.

    Args:
        Z (torch.tensor): Input of shape (data_points,input_dims).
        n (int): Number of samples.
        predict_y (boolean): Predict the data values \\(y\\) instead of the function values \\(f\\).
        prior (boolean): Sample from prior instead of posterior.

    Returns:
        torch.tensor: Samples of shape (data_points,samples) or (data_points,) if `n` is not given.
    &#34;&#34;&#34;
    with torch.no_grad():
        S = n
        if n is None:
            S = 1

        # TODO: predict_y and non-Gaussian likelihoods
        if prior:
            mu, var = self.mean(Z), self.kernel(Z)
        else:
            mu, var = self.predict(Z, full=True, tensor=True, predict_y=predict_y)  # MxD, MxMxD
        eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
        var += self.jitter * var.diagonal().mean() * eye  # MxM

        u = torch.normal(
                torch.zeros(Z.shape[0], S, device=config.device, dtype=config.dtype),
                torch.tensor(1.0, device=config.device, dtype=config.dtype))  # MxS
        L = torch.linalg.cholesky(var)  # MxM
        samples = mu + L.mm(u)  # MxS

        if n is None:
            samples = samples.squeeze()
        return samples.cpu().numpy()</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Model.zero_grad"><code class="name flex">
<span>def <span class="ident">zero_grad</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L184-L192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zero_grad(self):
    for p in self._params:
        p = p.unconstrained
        if p.grad is not None:
            if p.grad.grad_fn is not None:
                p.grad.detach_()
            else:
                p.grad.requires_grad_(False)
            p.grad.zero_()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mogptk.gpr.model.OpperArchambeau"><code class="flex name class">
<span>class <span class="ident">OpperArchambeau</span></span>
<span>(</span><span>kernel, X, y, likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name='OpperArchambeau')</span>
</code></dt>
<dd>
<div class="desc"><p>A Gaussian process regression based on Opper and Archambeau [1] with a non-Gaussian likelihood.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code><a title="mogptk.gpr.kernel.Kernel" href="kernel.html#mogptk.gpr.kernel.Kernel">Kernel</a></code></dt>
<dd>Kernel.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Output data of shape (data_points,).</dd>
<dt><strong><code>likelihood</code></strong> :&ensp;<code><a title="mogptk.gpr.likelihood.Likelihood" href="likelihood.html#mogptk.gpr.likelihood.Likelihood">Likelihood</a></code></dt>
<dd>Likelihood.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative jitter of the diagonal's mean added to the kernel's diagonal before calculating the Cholesky.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
</dl>
<p>[1] M. Opper, C. Archambeau, "The Variational Gaussian Approximation Revisited", 2009</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L563-L659" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OpperArchambeau(Model):
    &#34;&#34;&#34;
    A Gaussian process regression based on Opper and Archambeau [1] with a non-Gaussian likelihood.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] M. Opper, C. Archambeau, &#34;The Variational Gaussian Approximation Revisited&#34;, 2009
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, likelihood=GaussianLikelihood(1.0),
                 jitter=1e-8, mean=None, name=&#34;OpperArchambeau&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        n = self.X.shape[0]
        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.q_nu = Parameter(torch.zeros(n,1), name=&#34;q_nu&#34;)
        self.q_lambda = Parameter(torch.ones(n,1), name=&#34;q_lambda&#34;, lower=config.positive_minimum)
        self.likelihood = likelihood

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        q_nu = self.q_nu()
        q_lambda = self.q_lambda()

        Kff = self.kernel(self.X)  # NxN
        L = self._cholesky(q_lambda*q_lambda.T*Kff + self.eye)
        invL = torch.linalg.solve_triangular(L,self.eye,upper=False)  # NxN

        qf_mu = Kff.mm(q_nu)
        qf_var_diag = 1.0/q_lambda.square() - (invL.T.mm(invL)/q_lambda/q_lambda.T).diagonal().reshape(-1,1)

        kl = -q_nu.shape[0]
        kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
        kl += L.diagonal().square().log().sum()  # determinant TODO: is this correct?
        #kl += invL.diagonal().square().sum()  # trace
        kl += invL.square().sum()  # trace

        if self.mean is not None:
            qf_mu = qf_mu - self.mean(self.X).reshape(-1,1)  # Sx1
        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)

        #eye = torch.eye(q_lambda.shape[0], device=config.device, dtype=config.dtype)
        #qf_var = (1.0/q_lambda.square())*eye - invL.T.mm(invL)/q_lambda/q_lambda.T
        #kl = -q_nu.shape[0]
        #kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
        #kl -= qf_var.det().log()  # determinant
        #kl += invL.diagonal().square().sum()  # trace

        #kl = -q_nu.shape[0]
        #kl += q_nu.T.mm(q_nu).squeeze()  # Mahalanobis
        #kl -= qf_var.det().log()  # determinant
        #kl += qf_var_diag.sum()  # trace
        return var_exp - 0.5*kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            Kff = self.kernel(self.X)
            Kfs = self.kernel(self.X,Xs)  # NxS

            L = self._cholesky(Kff + (1.0/self.q_lambda().square()).diagflat())  # NxN
            a = torch.linalg.solve_triangular(L,Kfs,upper=False)  # NxS;  Kuu^(-1/2).Kus

            mu = Kfs.T.mm(self.q_nu())  # Sx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if full:
                Kss = self.kernel(Xs)  # SxS
                var = Kss - a.T.mm(a)  # SxS
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1)  # M
                var = var.reshape(-1,1)

            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.OpperArchambeau.elbo"><code class="name flex">
<span>def <span class="ident">elbo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L588-L625" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elbo(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    q_nu = self.q_nu()
    q_lambda = self.q_lambda()

    Kff = self.kernel(self.X)  # NxN
    L = self._cholesky(q_lambda*q_lambda.T*Kff + self.eye)
    invL = torch.linalg.solve_triangular(L,self.eye,upper=False)  # NxN

    qf_mu = Kff.mm(q_nu)
    qf_var_diag = 1.0/q_lambda.square() - (invL.T.mm(invL)/q_lambda/q_lambda.T).diagonal().reshape(-1,1)

    kl = -q_nu.shape[0]
    kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
    kl += L.diagonal().square().log().sum()  # determinant TODO: is this correct?
    #kl += invL.diagonal().square().sum()  # trace
    kl += invL.square().sum()  # trace

    if self.mean is not None:
        qf_mu = qf_mu - self.mean(self.X).reshape(-1,1)  # Sx1
    var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)

    #eye = torch.eye(q_lambda.shape[0], device=config.device, dtype=config.dtype)
    #qf_var = (1.0/q_lambda.square())*eye - invL.T.mm(invL)/q_lambda/q_lambda.T
    #kl = -q_nu.shape[0]
    #kl += q_nu.T.mm(qf_mu).squeeze()  # Mahalanobis
    #kl -= qf_var.det().log()  # determinant
    #kl += invL.diagonal().square().sum()  # trace

    #kl = -q_nu.shape[0]
    #kl += q_nu.T.mm(q_nu).squeeze()  # Mahalanobis
    #kl -= qf_var.det().log()  # determinant
    #kl += qf_var_diag.sum()  # trace
    return var_exp - 0.5*kl</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.OpperArchambeau.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L631-L659" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD

        Kff = self.kernel(self.X)
        Kfs = self.kernel(self.X,Xs)  # NxS

        L = self._cholesky(Kff + (1.0/self.q_lambda().square()).diagflat())  # NxN
        a = torch.linalg.solve_triangular(L,Kfs,upper=False)  # NxS;  Kuu^(-1/2).Kus

        mu = Kfs.T.mm(self.q_nu())  # Sx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Sx1

        if full:
            Kss = self.kernel(Xs)  # SxS
            var = Kss - a.T.mm(a)  # SxS
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1)  # M
            var = var.reshape(-1,1)

        if predict_y:
            mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Snelson"><code class="flex name class">
<span>class <span class="ident">Snelson</span></span>
<span>(</span><span>kernel, X, y, Z=10, Z_init='grid', variance=1.0, jitter=1e-08, mean=None, name='Snelson')</span>
</code></dt>
<dd>
<div class="desc"><p>A sparse Gaussian process regression based on Snelson and Ghahramani [1] with a Gaussian likelihood and inducing points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code><a title="mogptk.gpr.kernel.Kernel" href="kernel.html#mogptk.gpr.kernel.Kernel">Kernel</a></code></dt>
<dd>Kernel.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Output data of shape (data_points,).</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>int,torch.tensor</code></dt>
<dd>Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.</dd>
<dt><strong><code>Z_init</code></strong> :&ensp;<code>str</code></dt>
<dd>Method for initialization of inducing points, can be <code>grid</code>, <code>random</code>, or <code>density</code>.</dd>
<dt><strong><code>variance</code></strong> :&ensp;<code>float,torch.tensor</code></dt>
<dd>Gaussian likelihood initial variance. Passing a float will train a single variance for all channels. Passing a tensor of shape (channels,) will assign and train different variances per multi-output channel.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative jitter of the diagonal's mean added to the kernel's diagonal before calculating the Cholesky.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
</dl>
<p>[1] E. Snelson, Z. Ghahramani, "Sparse Gaussian Processes using Pseudo-inputs", 2005</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L459-L561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Snelson(Model):
    &#34;&#34;&#34;
    A sparse Gaussian process regression based on Snelson and Ghahramani [1] with a Gaussian likelihood and inducing points.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        Z (int,torch.tensor): Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.
        Z_init (str): Method for initialization of inducing points, can be `grid`, `random`, or `density`.
        variance (float,torch.tensor): Gaussian likelihood initial variance. Passing a float will train a single variance for all channels. Passing a tensor of shape (channels,) will assign and train different variances per multi-output channel.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] E. Snelson, Z. Ghahramani, &#34;Sparse Gaussian Processes using Pseudo-inputs&#34;, 2005
    &#34;&#34;&#34;
    def __init__(self, kernel, X, y, Z=10, Z_init=&#39;grid&#39;, variance=1.0, jitter=1e-8, mean=None,
                 name=&#34;Snelson&#34;):
        variance = Parameter.to_tensor(variance).squeeze()
        if 1 &lt; variance.ndim or variance.ndim == 1 and variance.shape[0] != kernel.output_dims:
            raise ValueError(&#34;variance must be float or have shape (channels,)&#34;)

        super().__init__(kernel, X, y, GaussianLikelihood(torch.sqrt(variance)), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, method=Z_init, output_dims=kernel.output_dims)
        Z = self._check_input(Z)
        
        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)
        if kernel.output_dims is not None:
            self.Z.num_parameters -= self.Z().shape[0]

    def log_marginal_likelihood(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel.K(self.Z(),self.X)  # MxN
        Kuu = self.kernel.K(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Luu = Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.scale().square(), self.X)  # N;  diag(Kff-Qff) + sigma^2.I
        G = torch.diagflat(1.0/g)  # N
        L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= 0.5*g.log().sum()
        p -= 0.5*y.T.mm(G).mm(y).squeeze()
        p += 0.5*c.T.mm(c).squeeze()
        return p

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kff_diag = self.kernel.K_diag(self.X)  # N
            Kuf = self.kernel.K(self.Z(),self.X)  # MxN
            Kuu = self.kernel.K(self.Z())  # MxM
            Kus = self.kernel.K(self.Z(),Xs)  # MxS

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.scale().square(), self.X)
            G = torch.diagflat(1.0/g)  # N
            L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxM
            b = torch.linalg.solve_triangular(L,a,upper=False)
            c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(w) + b.T.mm(u)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self._select_channel(self.likelihood.scale().square(), Xs) * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self._index_channel(self.likelihood.scale().square(), Xs)
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Snelson.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L518-L561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel.K(self.Z(),self.X)  # MxN
        Kuu = self.kernel.K(self.Z())  # MxM
        Kus = self.kernel.K(self.Z(),Xs)  # MxS

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        g = Kff_diag - v.T.square().sum(dim=1) + self._index_channel(self.likelihood.scale().square(), self.X)
        G = torch.diagflat(1.0/g)  # N
        L = self._cholesky(v.mm(G).mm(v.T) + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.G.Kfu.Kuu^(-1/2) + I)^(1/2)

        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxM
        b = torch.linalg.solve_triangular(L,a,upper=False)
        c = torch.linalg.solve_triangular(L,v.mm(G).mm(y),upper=False)  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.G.y

        mu = b.T.mm(c)  # Mx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Mx1

        if full:
            Kss = self.kernel(Xs)  # MxM
            var = Kss - a.T.mm(w) + b.T.mm(u)  # MxM
            if predict_y:
                eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                var += self._select_channel(self.likelihood.scale().square(), Xs) * eye
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            if predict_y:
                var += self._index_channel(self.likelihood.scale().square(), Xs)
            var = var.reshape(-1,1)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.SparseHensman"><code class="flex name class">
<span>class <span class="ident">SparseHensman</span></span>
<span>(</span><span>kernel, X, y, Z=None, Z_init='grid', likelihood=&lt;mogptk.gpr.likelihood.GaussianLikelihood object&gt;, jitter=1e-08, mean=None, name='SparseHensman')</span>
</code></dt>
<dd>
<div class="desc"><p>A sparse Gaussian process regression based on Hensman et al. [1] with a non-Gaussian likelihood.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code><a title="mogptk.gpr.kernel.Kernel" href="kernel.html#mogptk.gpr.kernel.Kernel">Kernel</a></code></dt>
<dd>Kernel.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Output data of shape (data_points,).</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>int,torch.tensor</code></dt>
<dd>Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.</dd>
<dt><strong><code>Z_init</code></strong> :&ensp;<code>str</code></dt>
<dd>Method for initialization of inducing points, can be <code>grid</code>, <code>random</code>, or <code>density</code>.</dd>
<dt><strong><code>likelihood</code></strong> :&ensp;<code><a title="mogptk.gpr.likelihood.Likelihood" href="likelihood.html#mogptk.gpr.likelihood.Likelihood">Likelihood</a></code></dt>
<dd>Likelihood.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative jitter of the diagonal's mean added to the kernel's diagonal before calculating the Cholesky.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
</dl>
<p>[1] J. Hensman, et al., "Scalable Variational Gaussian Process Classification", 2015</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L770-L879" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SparseHensman(Model):
    &#34;&#34;&#34;
    A sparse Gaussian process regression based on Hensman et al. [1] with a non-Gaussian likelihood.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        Z (int,torch.tensor): Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.
        Z_init (str): Method for initialization of inducing points, can be `grid`, `random`, or `density`.
        likelihood (mogptk.gpr.likelihood.Likelihood): Likelihood.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] J. Hensman, et al., &#34;Scalable Variational Gaussian Process Classification&#34;, 2015
    &#34;&#34;&#34;
    # This version replaces mu_q by L.mu_q and sigma_q by L.sigma_q.L^T, where LL^T = Kuu
    # So that p(u) ~ N(0,1) and q(u) ~ N(L.mu_q, L.sigma_q.L^T)
    def __init__(self, kernel, X, y, Z=None, Z_init=&#39;grid&#39;,
                 likelihood=GaussianLikelihood(1.0), jitter=1e-8, mean=None,
                 name=&#34;SparseHensman&#34;):
        super().__init__(kernel, X, y, likelihood, jitter, mean, name)

        n = self.X.shape[0]
        self.is_sparse = Z is not None
        if self.is_sparse:
            Z = init_inducing_points(Z, self.X, method=Z_init, output_dims=kernel.output_dims)
            Z = self._check_input(Z)
            n = Z.shape[0]

        self.eye = torch.eye(n, device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.q_mu = Parameter(torch.zeros(n,1), name=&#34;q_mu&#34;)
        self.q_sqrt = Parameter(torch.eye(n), name=&#34;q_sqrt&#34;)
        self.q_sqrt.num_parameters = int((n*n+n)/2)
        if self.is_sparse:
            self.Z = Parameter(Z, name=&#34;induction_points&#34;)
            if kernel.output_dims is not None:
                self.Z.num_parameters -= self.Z().shape[0]
        else:
            self.Z = Parameter(self.X, train=False)  # don&#39;t use inducing points

    def kl_gaussian(self, q_mu, q_sqrt):
        S_diag = q_sqrt.diagonal().square() # NxN
        kl = -q_mu.shape[0]
        kl += q_mu.T.mm(q_mu).squeeze()  # Mahalanobis
        kl -= S_diag.log().sum()  # determinant of q_var
        kl += S_diag.sum()  # same as Trace(p_var^(-1).q_var)
        return 0.5*kl

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        if self.is_sparse:
            qf_mu, qf_var_diag = self._predict(self.X, full=False)
        else:
            Kff = self.kernel(self.X)
            Lff = self._cholesky(Kff, add_jitter=True)  # NxN

            qf_mu = Lff.mm(self.q_mu())
            if self.mean is not None:
                qf_mu -= self.mean(self.X).reshape(-1,1)  # Sx1

            qf_sqrt = Lff.mm(self.q_sqrt().tril())
            qf_var_diag = qf_sqrt.mm(qf_sqrt.T).diagonal().reshape(-1,1)

        var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)
        kl = self.kl_gaussian(self.q_mu(), self.q_sqrt())
        return var_exp - kl

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def _predict(self, Xs, full=False):
        Kuu = self.kernel(self.Z())
        Kus = self.kernel(self.Z(),Xs)  # NxS

        Luu = self._cholesky(Kuu, add_jitter=True)  # NxN
        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # NxS;  Kuu^(-1/2).Kus
        b = self.q_sqrt().tril().T.mm(torch.linalg.solve_triangular(Luu,Kus,upper=False))

        mu = Kus.T.mm(torch.linalg.solve_triangular(Luu.T,self.q_mu(),upper=True))  # Sx1
        if full:
            Kss = self.kernel(Xs)  # SxS
            var = Kss - a.T.mm(a) + b.T.mm(b)  # SxS
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            var = var.reshape(-1,1)
        return mu, var

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD

            mu, var = self._predict(Xs, full=full)
            if predict_y:
                mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Sx1

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Hensman" href="#mogptk.gpr.model.Hensman">Hensman</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.SparseHensman.elbo"><code class="name flex">
<span>def <span class="ident">elbo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L821-L842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elbo(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    if self.is_sparse:
        qf_mu, qf_var_diag = self._predict(self.X, full=False)
    else:
        Kff = self.kernel(self.X)
        Lff = self._cholesky(Kff, add_jitter=True)  # NxN

        qf_mu = Lff.mm(self.q_mu())
        if self.mean is not None:
            qf_mu -= self.mean(self.X).reshape(-1,1)  # Sx1

        qf_sqrt = Lff.mm(self.q_sqrt().tril())
        qf_var_diag = qf_sqrt.mm(qf_sqrt.T).diagonal().reshape(-1,1)

    var_exp = self.likelihood.variational_expectation(y, qf_mu, qf_var_diag, X=self.X)
    kl = self.kl_gaussian(self.q_mu(), self.q_sqrt())
    return var_exp - kl</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.SparseHensman.kl_gaussian"><code class="name flex">
<span>def <span class="ident">kl_gaussian</span></span>(<span>self, q_mu, q_sqrt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L813-L819" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def kl_gaussian(self, q_mu, q_sqrt):
    S_diag = q_sqrt.diagonal().square() # NxN
    kl = -q_mu.shape[0]
    kl += q_mu.T.mm(q_mu).squeeze()  # Mahalanobis
    kl -= S_diag.log().sum()  # determinant of q_var
    kl += S_diag.sum()  # same as Trace(p_var^(-1).q_var)
    return 0.5*kl</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.SparseHensman.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L866-L879" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD

        mu, var = self._predict(Xs, full=full)
        if predict_y:
            mu, var = self.likelihood.predict(mu, var, full=full, X=Xs)
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Sx1

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mogptk.gpr.model.Titsias"><code class="flex name class">
<span>class <span class="ident">Titsias</span></span>
<span>(</span><span>kernel, X, y, Z, Z_init='grid', variance=1.0, jitter=1e-08, mean=None, name='Titsias')</span>
</code></dt>
<dd>
<div class="desc"><p>A sparse Gaussian process regression based on Titsias [1] with a Gaussian likelihood.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kernel</code></strong> :&ensp;<code><a title="mogptk.gpr.kernel.Kernel" href="kernel.html#mogptk.gpr.kernel.Kernel">Kernel</a></code></dt>
<dd>Kernel.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Input data of shape (data_points,input_dims).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>torch.tensor</code></dt>
<dd>Output data of shape (data_points,).</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>int,torch.tensor</code></dt>
<dd>Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.</dd>
<dt><strong><code>Z_init</code></strong> :&ensp;<code>str</code></dt>
<dd>Method for initialization of inducing points, can be <code>grid</code>, <code>random</code>, or <code>density</code>.</dd>
<dt><strong><code>variance</code></strong> :&ensp;<code>float</code></dt>
<dd>Gaussian likelihood initial variance.</dd>
<dt><strong><code>jitter</code></strong> :&ensp;<code>float</code></dt>
<dd>Relative jitter of the diagonal's mean added to the kernel's diagonal before calculating the Cholesky.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code><a title="mogptk.gpr.mean.Mean" href="mean.html#mogptk.gpr.mean.Mean">Mean</a></code></dt>
<dd>Mean.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the model.</dd>
</dl>
<p>[1] Titsias, "Variational learning of induced variables in sparse Gaussian processes", 2009</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L661-L768" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Titsias(Model):
    &#34;&#34;&#34;
    A sparse Gaussian process regression based on Titsias [1] with a Gaussian likelihood.

    Args:
        kernel (mogptk.gpr.kernel.Kernel): Kernel.
        X (torch.tensor): Input data of shape (data_points,input_dims).
        y (torch.tensor): Output data of shape (data_points,).
        Z (int,torch.tensor): Number of inducing points to be distributed over the input space. Passing a tensor of shape (inducing_points,input_dims) sets the initial positions of the inducing points.
        Z_init (str): Method for initialization of inducing points, can be `grid`, `random`, or `density`.
        variance (float): Gaussian likelihood initial variance.
        jitter (float): Relative jitter of the diagonal&#39;s mean added to the kernel&#39;s diagonal before calculating the Cholesky.
        mean (mogptk.gpr.mean.Mean): Mean.
        name (str): Name of the model.

    [1] Titsias, &#34;Variational learning of induced variables in sparse Gaussian processes&#34;, 2009
    &#34;&#34;&#34;
    # See: http://krasserm.github.io/2020/12/12/gaussian-processes-sparse/
    def __init__(self, kernel, X, y, Z, Z_init=&#39;grid&#39;, variance=1.0, jitter=1e-8,
                 mean=None, name=&#34;Titsias&#34;):
        # TODO: variance per channel
        variance = Parameter.to_tensor(variance)
        super().__init__(kernel, X, y, GaussianLikelihood(torch.sqrt(variance)), jitter, mean, name)

        Z = init_inducing_points(Z, self.X, method=Z_init, output_dims=kernel.output_dims)
        Z = self._check_input(Z)

        self.eye = torch.eye(Z.shape[0], device=config.device, dtype=config.dtype)
        self.log_marginal_likelihood_constant = 0.5*self.X.shape[0]*np.log(2.0*np.pi)
        self.Z = Parameter(Z, name=&#34;induction_points&#34;)
        if kernel.output_dims is not None:
            self.Z.num_parameters -= self.Z().shape[0]

    def elbo(self):
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kff_diag = self.kernel.K_diag(self.X)  # N
        Kuf = self.kernel(self.Z(),self.X)  # MxN
        Kuu = self.kernel(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        Q = v.mm(v.T)  # MxM;  Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)
        L = self._cholesky(Q/self.likelihood.scale().square() + self.eye)  # MxM;  (Q/sigma^2 + I)^(1/2)

        c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.scale().square()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

        # p = log N(0, Kfu.Kuu^(-1).Kuf + I/sigma^2) - 1/(2.sigma^2).Trace(Kff - Kfu.Kuu^(-1).Kuf)
        p = -self.log_marginal_likelihood_constant
        p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
        p -= self.X.shape[0]*self.likelihood.scale().log()
        p -= 0.5*y.T.mm(y).squeeze()/self.likelihood.scale().square()
        p += 0.5*c.T.mm(c).squeeze()
        p -= 0.5*(Kff_diag.sum() - Q.trace())/self.likelihood.scale().square() # trace
        return p

    def log_marginal_likelihood(self):
        # maximize the lower bound
        return self.elbo()

    def predict(self, Xs, full=False, tensor=False, predict_y=True):
        with torch.no_grad():
            Xs = self._check_input(Xs)  # MxD
            if self.mean is not None:
                y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
            else:
                y = self.y  # Nx1

            Kus = self.kernel(self.Z(),Xs)  # MxS
            Kuf = self.kernel(self.Z(),self.X)  # MxN
            Kuu = self.kernel(self.Z())  # MxM

            Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
            v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
            L = self._cholesky(v.mm(v.T)/self.likelihood.scale().square() + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)/sigma^2 + I)^(1/2)

            a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # MxS;  Kuu^(-1/2).Kus
            b = torch.linalg.solve_triangular(L,a,upper=False)  # MxS;  L^(-1).Kuu^(-1/2).Kus
            c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.scale().square()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

            # mu = sigma^(-2).Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kuf.y
            mu = b.T.mm(c)  # Mx1
            if self.mean is not None:
                mu += self.mean(Xs).reshape(-1,1)  # Mx1

            # var = Kss - Qsf.(Qff + sigma^2 I)^(-1).Qfs
            # below is the equivalent but more stable version by using the matrix inversion lemma
            # var = Kss - Ksu.Kuu^(-1).Kus + Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kus
            if full:
                Kss = self.kernel(Xs)  # MxM
                var = Kss - a.T.mm(a) + b.T.mm(b)  # MxM
                if predict_y:
                    eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                    var += self.likelihood.scale().square() * eye
            else:
                Kss_diag = self.kernel.K_diag(Xs)  # M
                var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
                if predict_y:
                    var += self.likelihood.scale().square()
                var = var.reshape(-1,1)

            if tensor:
                return mu, var
            else:
                return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.gpr.model.Titsias.elbo"><code class="name flex">
<span>def <span class="ident">elbo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L694-L718" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def elbo(self):
    if self.mean is not None:
        y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
    else:
        y = self.y  # Nx1

    Kff_diag = self.kernel.K_diag(self.X)  # N
    Kuf = self.kernel(self.Z(),self.X)  # MxN
    Kuu = self.kernel(self.Z())  # MxM

    Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
    v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
    Q = v.mm(v.T)  # MxM;  Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)
    L = self._cholesky(Q/self.likelihood.scale().square() + self.eye)  # MxM;  (Q/sigma^2 + I)^(1/2)

    c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.scale().square()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

    # p = log N(0, Kfu.Kuu^(-1).Kuf + I/sigma^2) - 1/(2.sigma^2).Trace(Kff - Kfu.Kuu^(-1).Kuf)
    p = -self.log_marginal_likelihood_constant
    p -= L.diagonal().log().sum() # 0.5 is taken as the square root of L
    p -= self.X.shape[0]*self.likelihood.scale().log()
    p -= 0.5*y.T.mm(y).squeeze()/self.likelihood.scale().square()
    p += 0.5*c.T.mm(c).squeeze()
    p -= 0.5*(Kff_diag.sum() - Q.trace())/self.likelihood.scale().square() # trace
    return p</code></pre>
</details>
</dd>
<dt id="mogptk.gpr.model.Titsias.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, Xs, full=False, tensor=False, predict_y=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/GAMES-UChile/mogptk/blob/cdf21a6f4a499e5e8ab10b9101c4b7b6294540eb/mogptk/gpr/model.py#L724-L768" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def predict(self, Xs, full=False, tensor=False, predict_y=True):
    with torch.no_grad():
        Xs = self._check_input(Xs)  # MxD
        if self.mean is not None:
            y = self.y - self.mean(self.X).reshape(-1,1)  # Nx1
        else:
            y = self.y  # Nx1

        Kus = self.kernel(self.Z(),Xs)  # MxS
        Kuf = self.kernel(self.Z(),self.X)  # MxN
        Kuu = self.kernel(self.Z())  # MxM

        Luu = self._cholesky(Kuu, add_jitter=True)  # MxM;  Kuu^(1/2)
        v = torch.linalg.solve_triangular(Luu,Kuf,upper=False)  # MxN;  Kuu^(-1/2).Kuf
        L = self._cholesky(v.mm(v.T)/self.likelihood.scale().square() + self.eye)  # MxM;  (Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2)/sigma^2 + I)^(1/2)

        a = torch.linalg.solve_triangular(Luu,Kus,upper=False)  # MxS;  Kuu^(-1/2).Kus
        b = torch.linalg.solve_triangular(L,a,upper=False)  # MxS;  L^(-1).Kuu^(-1/2).Kus
        c = torch.linalg.solve_triangular(L,v.mm(y),upper=False)/self.likelihood.scale().square()  # Mx1;  L^(-1).Kuu^(-1/2).Kuf.y

        # mu = sigma^(-2).Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kuf.y
        mu = b.T.mm(c)  # Mx1
        if self.mean is not None:
            mu += self.mean(Xs).reshape(-1,1)  # Mx1

        # var = Kss - Qsf.(Qff + sigma^2 I)^(-1).Qfs
        # below is the equivalent but more stable version by using the matrix inversion lemma
        # var = Kss - Ksu.Kuu^(-1).Kus + Ksu.Kuu^(-1/2).(sigma^(-2).Kuu^(-1/2).Kuf.Kfu.Kuu^(-1/2) + I)^(-1).Kuu^(-1/2).Kus
        if full:
            Kss = self.kernel(Xs)  # MxM
            var = Kss - a.T.mm(a) + b.T.mm(b)  # MxM
            if predict_y:
                eye = torch.eye(var.shape[0], device=config.device, dtype=config.dtype)
                var += self.likelihood.scale().square() * eye
        else:
            Kss_diag = self.kernel.K_diag(Xs)  # M
            var = Kss_diag - a.T.square().sum(dim=1) + b.T.square().sum(dim=1)  # M
            if predict_y:
                var += self.likelihood.scale().square()
            var = var.reshape(-1,1)

        if tensor:
            return mu, var
        else:
            return mu.cpu().numpy(), var.cpu().numpy()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mogptk.gpr" href="index.html">mogptk.gpr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mogptk.gpr.model.init_inducing_points" href="#mogptk.gpr.model.init_inducing_points">init_inducing_points</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mogptk.gpr.model.CholeskyException" href="#mogptk.gpr.model.CholeskyException">CholeskyException</a></code></h4>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Exact" href="#mogptk.gpr.model.Exact">Exact</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Exact.predict" href="#mogptk.gpr.model.Exact.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Hensman" href="#mogptk.gpr.model.Hensman">Hensman</a></code></h4>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Model" href="#mogptk.gpr.model.Model">Model</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Model.K" href="#mogptk.gpr.model.Model.K">K</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.get_parameters" href="#mogptk.gpr.model.Model.get_parameters">get_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_marginal_likelihood" href="#mogptk.gpr.model.Model.log_marginal_likelihood">log_marginal_likelihood</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.log_prior" href="#mogptk.gpr.model.Model.log_prior">log_prior</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.loss" href="#mogptk.gpr.model.Model.loss">loss</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.parameters" href="#mogptk.gpr.model.Model.parameters">parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.print_parameters" href="#mogptk.gpr.model.Model.print_parameters">print_parameters</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.sample" href="#mogptk.gpr.model.Model.sample">sample</a></code></li>
<li><code><a title="mogptk.gpr.model.Model.zero_grad" href="#mogptk.gpr.model.Model.zero_grad">zero_grad</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.OpperArchambeau" href="#mogptk.gpr.model.OpperArchambeau">OpperArchambeau</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.OpperArchambeau.elbo" href="#mogptk.gpr.model.OpperArchambeau.elbo">elbo</a></code></li>
<li><code><a title="mogptk.gpr.model.OpperArchambeau.predict" href="#mogptk.gpr.model.OpperArchambeau.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Snelson" href="#mogptk.gpr.model.Snelson">Snelson</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Snelson.predict" href="#mogptk.gpr.model.Snelson.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.SparseHensman" href="#mogptk.gpr.model.SparseHensman">SparseHensman</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.SparseHensman.elbo" href="#mogptk.gpr.model.SparseHensman.elbo">elbo</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.kl_gaussian" href="#mogptk.gpr.model.SparseHensman.kl_gaussian">kl_gaussian</a></code></li>
<li><code><a title="mogptk.gpr.model.SparseHensman.predict" href="#mogptk.gpr.model.SparseHensman.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mogptk.gpr.model.Titsias" href="#mogptk.gpr.model.Titsias">Titsias</a></code></h4>
<ul class="">
<li><code><a title="mogptk.gpr.model.Titsias.elbo" href="#mogptk.gpr.model.Titsias.elbo">elbo</a></code></li>
<li><code><a title="mogptk.gpr.model.Titsias.predict" href="#mogptk.gpr.model.Titsias.predict">predict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>